<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cryptocurrency & Forex Integrated Analysis Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <!-- 1. Integration of Deep Learning Models: TensorFlow.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(-45deg, #111827, #1f2937, #374151, #4b5563);
            background-size: 400% 400%;
            animation: gradient 15s ease infinite;
        }
        @keyframes gradient { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        .rank-badge { width: 40px; height: 40px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-weight: bold; color: white; flex-shrink: 0; }
        .rank-1 { background-color: #f9b115; box-shadow: 0 0 15px #f9b115; }
        .rank-2 { background-color: #adb5bd; box-shadow: 0 0 15px #adb5bd; }
        .rank-3 { background-color: #cd7f32; box-shadow: 0 0 15px #cd7f32; }
        .tab-button.active { color: white; border-color: #6366f1; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #4b5563; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #4f46e5; }
        input:checked + .slider:before { transform: translateX(22px); }
        #toast-container { position: fixed; top: 20px; right: 20px; z-index: 1050; }
        .toast { background-color: #1f2937; color: white; padding: 15px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); border-left: 4px solid; margin-bottom: 10px; opacity: 0; transform: translateX(100%); animation: slideIn 0.5s forwards; }
        .toast.success { border-color: #22c55e; } .toast.error { border-color: #ef4444; } .toast.info { border-color: #3b82f6; }
        @keyframes slideIn { to { opacity: 1; transform: translateX(0); } }
        
        .meter-container { width: 160px; height: 80px; position: relative; margin: 0 auto; }
        .meter-bg, .meter-value { width: 160px; height: 80px; border-radius: 80px 80px 0 0; position: absolute; top: 0; left: 0; }
        .meter-bg { background: linear-gradient(to right, #ef4444, #facc15, #22c55e); }
        .meter-value { background-color: #374151; clip-path: polygon(50% 100%, 0 100%, 0 0, 100% 0, 100% 100%); }
        .meter-pointer { width: 2px; height: 75px; background-color: white; position: absolute; bottom: 0; left: 50%; transform-origin: bottom center; transition: transform 0.5s ease-out; }
        .meter-center { width: 12px; height: 12px; background-color: white; border-radius: 50%; position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); }
        
        @keyframes flash-yellow {
            0%, 100% { border-color: #4b5563; }
            50% { border-color: #fbbf24; box-shadow: 0 0 15px #fbbf24; }
        }
        .signal-changed {
            animation: flash-yellow 1.5s infinite;
        }
        
        .price-ticker {
            overflow: hidden;
            position: relative;
            background: rgba(17, 24, 39, 0.8);
            border-bottom: 1px solid #374151;
            padding: 0.5rem 0;
        }
        .ticker-wrap {
            width: 100%;
            display: flex;
        }
        .ticker-container {
            display: flex;
            animation: ticker-scroll 90s linear infinite; /* Adjusted speed for more items */
        }
        .ticker-item {
            display: flex;
            align-items: center;
            padding: 0 1.5rem;
            white-space: nowrap;
            font-size: 0.875rem;
        }
        @keyframes ticker-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-100%); }
        }

        .progress-bar-bg {
            background-color: #374151;
            border-radius: 9999px;
            height: 8px;
            width: 100%;
            position: relative;
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            border-radius: 9999px;
            transition: width 0.3s ease-in-out;
        }
        .timeframe-btn {
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 6px;
            background-color: #4b5563;
            color: #d1d5db;
            transition: background-color 0.2s;
        }
        .condition-filter-btn:hover {
            background-color: #6b7280;
        }
        .condition-filter-btn.active {
            background-color: #6366f1;
            color: white;
            font-weight: bold;
        }
        .tooltip { position: relative; display: inline-block; cursor: pointer; }
        .tooltip .tooltiptext { visibility: hidden; width: 220px; background-color: #1f2937; color: #fff; text-align: center; border-radius: 6px; padding: 5px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; box-shadow: 0 2px 10px rgba(0,0,0,0.5); font-size: 12px;}
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .impulse-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 8px;
        }
        .impulse-green { background-color: #22c55e; box-shadow: 0 0 8px #22c55e; }
        .impulse-red { background-color: #ef4444; box-shadow: 0 0 8px #ef4444; }
        .impulse-blue { background-color: #3b82f6; box-shadow: 0 0 8px #3b82f6; }


        @media (max-width: 768px) {
            .container {
                padding: 0.5rem;
            }
            .control-panel {
                flex-direction: column;
                gap: 1rem;
            }
            .tab-buttons {
                overflow-x: auto;
                white-space: nowrap;
            }
        }
        /* ★★★ START: 最適化プログレス表示用のスタイルを追加 ★★★ */
        .ga-params-display {
            font-family: monospace;
            font-size: 0.7rem;
            word-break: break-all;
        }
        /* ★★★ END: 最適化プログレス表示用のスタイルを追加 ★★★ */
        /* 信頼度ランクバッジのスタイル */
        .confidence-badge {
            display: inline-block;
            padding: 0.25em 0.5em;
            border-radius: 0.25rem;
            font-weight: bold;
            font-size: 0.75rem;
            margin-left: 0.5rem;
        }
        .confidence-S {
            background-color: #f9b115;
            color: black;
        }
        .confidence-APlus {
            background-color: #ef4444;
            color: white;
        }
        .confidence-A {
            background-color: #10b981;
            color: white;
        }
        .confidence-B {
            background-color: #3b82f6;
            color: white;
        }
        .confidence-C {
            background-color: #8b5cf6;
            color: white;
        }
    </style>
</head>
<!--
/**************************************************************
 * @project: Integrated Analysis Tool
 * @author_signature: NIshimura Ryuto
 * @build_timestamp: 1726413540
 **************************************************************/
-->
<body class="bg-gray-900 text-gray-200">
    <div id="toast-container"></div>
    
    <!-- Price Ticker -->
    <div class="price-ticker">
        <div class="ticker-wrap">
            <div id="price-ticker-container" class="ticker-container">
                <!-- Ticker items will be duplicated by JS -->
            </div>
        </div>
    </div>
    
    <div class="container mx-auto p-4 max-w-5xl">
        <header class="text-center mb-8 relative">
            <h1 class="text-4xl font-bold text-white mb-2">Integrated Analysis Tool</h1>
            <p class="text-gray-400">仮想通貨・為替統合分析エンジン</p>
            <div id="header-menu" class="absolute top-0 right-0">
                <button id="menu-button" class="p-2 rounded-md hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7" /></svg>
                </button>
                <div id="menu-dropdown" class="absolute right-0 mt-2 w-48 bg-gray-800 rounded-md shadow-lg z-20 hidden">
                    <a href="#" id="menu-settings" class="block px-4 py-2 text-sm text-gray-300 hover:bg-gray-700">設定＆バックテスト</a>
                    <a href="#" id="menu-ai-analysis" class="block px-4 py-2 text-sm text-gray-300 hover:bg-gray-700">AIモデル分析</a>
                    <a href="#" id="menu-notifications" class="block px-4 py-2 text-sm text-gray-300 hover:bg-gray-700">通知設定</a>
                    <a href="#" id="menu-qa" class="block px-4 py-2 text-sm text-gray-300 hover:bg-gray-700">Q&A ヘルプ</a>
                </div>
            </div>
        </header>
        <main id="main-content">
              <!-- Quick Price View -->
            <div id="quick-price-view" class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4 mb-8">
                <!-- Quick price items will be populated by JS -->
            </div>

            <!-- Daytrade Dashboard -->
            <div class="bg-gray-800/50 backdrop-blur-sm p-6 rounded-xl shadow-lg mb-8 border border-gray-700">
                <h2 class="text-2xl font-bold text-white mb-4 text-center">注目アセットダッシュボード</h2>
                <div id="dashboard-meters-container" class="grid grid-cols-1 md:grid-cols-3 gap-6 w-full">
                    <!-- Dashboard meters will be populated here -->
                </div>
            </div>

            <!-- Control Panel -->
            <div class="bg-gray-800/50 backdrop-blur-sm p-4 rounded-xl shadow-lg mb-8 border border-gray-700">
                <div class="control-panel flex flex-col md:flex-row items-center justify-between gap-4">
                    <div class="w-full md:w-auto flex-shrink-0">
                        <label for="timeframe-select" class="block text-sm font-semibold text-gray-400 mb-1">分析時間足</label>
                        <select id="timeframe-select" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <option value="minute">1分足 (スキャルピング)</option>
                            <option value="5minute">5分足 (デイトレード)</option>
                            <option value="15minute">15分足 (デイトレード)</option>
                            <option value="hour" selected>1時間足 (スイング)</option>
                            <option value="4hour">4時間足 (スイング)</option>
                            <option value="day">日足 (長期)</option>
                        </select>
                    </div>
                    <button id="run-analysis" class="w-full md:w-auto flex-grow bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-all duration-300 flex items-center justify-center text-lg shadow-lg hover:shadow-indigo-500/50 transform hover:-translate-y-1 disabled:opacity-50 disabled:cursor-not-allowed">
                        <svg id="loading-spinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                        <span id="button-text">総合分析を実行</span>
                    </button>
                    <!-- ★★★ START: 最適化ボタンとレベル選択をグループ化 ★★★ -->
                    <div class="flex items-center gap-2">
                        <button id="optimize-indicators" class="flex-shrink-0 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 flex items-center justify-center text-base shadow-lg hover:shadow-green-500/50 transform hover:-translate-y-1 disabled:opacity-50 disabled:cursor-not-allowed">
                            <svg id="optimize-spinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                            <span>指標の最適化</span>
                        </button>
                        <select id="optimization-level-select" class="bg-gray-700 border border-gray-600 rounded-md py-3 px-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 text-sm">
                            <option value="fast">高速(1分)</option>
                            <option value="balanced" selected>バランス(3分)</option>
                            <option value="thorough">詳細(10分)</option>
                        </select>
                    </div>
                    <!-- ★★★ END: 最適化ボタンとレベル選択をグループ化 ★★★ -->
                    <div class="w-full md:w-auto flex-shrink-0">
                        <label for="timeout-select" class="block text-sm font-semibold text-gray-400 mb-1">タイムアウト設定</label>
                        <select id="timeout-select" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <option value="2">2時間 (短期)</option>
                            <option value="4" selected>4時間 (推奨・バランス)</option>
                            <option value="8">8時間 (長期)</option>
                        </select>
                    </div>
                    <div class="flex items-center gap-4 text-white flex-shrink-0">
                        <label for="auto-refresh-toggle" class="font-semibold">自動更新</label>
                        <label class="switch"><input type="checkbox" id="auto-refresh-toggle"><span class="slider"></span></label>
                        <div id="countdown-timer" class="text-sm text-gray-400 w-28"></div>
                    </div>
                </div>
                <div id="optimization-status" class="text-xs text-center text-gray-400 mt-2 h-4"></div>
            </div>

            <!-- Open Positions Section -->
            <div id="positions-section" class="mb-8 hidden">
                <h2 class="text-2xl font-bold text-white mb-4">保有ポジション</h2>
                <div id="positions-container" class="space-y-4"></div>
            </div>

            <!-- Main Content Grid -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <div class="lg:col-span-2">
                    <!-- Tabs -->
                    <div class="mb-6 flex border-b border-gray-700 tab-buttons">
                        <button id="tab-ranking" class="tab-button active px-4 py-2 text-white border-b-2 border-indigo-500 font-semibold">ランキング</button>
                        <button id="tab-all" class="tab-button px-4 py-2 text-gray-400 border-b-2 border-transparent font-semibold">全アセット</button>
                        <button id="tab-history" class="tab-button px-4 py-2 text-gray-400 border-b-2 border-transparent font-semibold">分析履歴</button>
                        <button id="tab-trade-history" class="tab-button px-4 py-2 text-gray-400 border-b-2 border-transparent font-semibold">取引履歴</button>
                    </div>
                    <!-- Tab Content -->
                    <div id="tab-content">
                        <div id="ranking-panel" class="space-y-6"></div>
                        <div id="all-pairs-panel" class="hidden space-y-6"></div>
                        <div id="history-panel" class="hidden space-y-8"></div>
                        <div id="trade-history-panel" class="hidden space-y-4"></div>
                    </div>
                </div>
                <!-- Accuracy Tracker Sidebar -->
                <div class="lg:col-span-1">
                    <div class="bg-gray-800/50 backdrop-blur-sm p-6 rounded-xl shadow-lg border border-gray-700 sticky top-4">
                        <div class="flex items-center justify-center gap-2 mb-4">
                            <h2 class="text-2xl font-bold text-white text-center">シグナル正答率</h2>
                            <div class="tooltip">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" /></svg>
                                <span class="tooltiptext" id="accuracy-tooltip-text">判定ロジックの詳細</span>
                            </div>
                        </div>
                        <div class="text-center mb-4"><p id="accuracy-rate" class="text-5xl font-bold text-indigo-400">---</p></div>
                        <div class="space-y-3 text-sm">
                            <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg"><span class="font-semibold text-gray-300">検証済みシグナル数:</span><span id="total-verified" class="font-bold text-white">0</span></div>
                            <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg"><span class="font-semibold text-green-400">成功シグナル数:</span><span id="successful-signals" class="font-bold text-white">0</span></div>
                            <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg"><span class="font-semibold text-red-400">失敗シグナル数:</span><span id="failed-signals" class="font-bold text-white">0</span></div>
                        </div>
                        <button id="reset-history-btn" class="w-full mt-4 text-xs bg-gray-600 hover:bg-gray-500 text-white py-2 px-3 rounded-lg transition-colors">全履歴をリセット</button>
                        
                        <!-- 詳細な確証率表示用のHTMLを追加 -->
                        <div class="mt-6 bg-gray-800/50 p-4 rounded-xl">
                            <h3 class="text-lg font-bold text-white mb-4">詳細な確証率分析</h3>
                            <div id="advanced-stats-container">
                                <!-- ここに詳細統計が表示されます -->
                            </div>
                            
                            <div class="mt-4">
                                <h4 class="text-sm font-semibold text-gray-300 mb-2">条件別勝率</h4>
                                <div class="flex overflow-x-auto space-x-2 pb-2">
                                    <button class="condition-filter-btn active" data-filter="timeframe">時間足別</button>
                                    <button class="condition-filter-btn" data-filter="score">スコア別</button>
                                    <button class="condition-filter-btn" data-filter="session">時間帯別</button>
                                    <button class="condition-filter-btn" data-filter="regime">相場別</button>
                                </div>
                                <div id="condition-wise-stats" class="mt-2">
                                    <!-- 条件別の統計が表示されます -->
                                </div>
                            </div>
                            
                            <div class="mt-4 p-3 bg-gray-900/50 rounded-lg">
                                <h4 class="text-sm font-semibold text-gray-300 mb-2">勝率トレンド</h4>
                                <div class="w-full h-40">
                                    <canvas id="win-rate-trend-chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
        
        <!-- Modals -->
        <div id="chart-modal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
            <div class="bg-gray-800 rounded-xl shadow-xl w-full max-w-4xl h-3/4 flex flex-col border border-gray-700">
                <div class="flex justify-between items-center p-4 border-b border-gray-700">
                    <h3 class="text-lg font-bold text-white" id="chart-modal-title">チャート分析</h3>
                    <div id="chart-timeframe-selector" class="flex-grow flex justify-center gap-1">
                        <!-- Timeframe buttons will be populated by JS -->
                    </div>
                    <button id="close-chart-modal" class="text-gray-400 hover:text-white text-2xl font-bold">&times;</button>
                </div>
                <div class="flex-1 p-4 relative">
                    <div id="chart-loading-overlay" class="absolute inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center hidden z-10">
                        <p class="text-white text-lg">チャートデータを読み込み中...</p>
                    </div>
                    <canvas id="chart-canvas"></canvas>
                </div>
            </div>
        </div>

        <div id="trade-entry-modal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
            <div class="bg-gray-800 rounded-xl shadow-xl w-full max-w-sm border border-gray-700">
                <div class="p-6 space-y-4">
                    <h3 id="trade-entry-title" class="text-xl font-bold text-white text-center"></h3>
                    <div>
                        <label for="trade-amount" id="trade-amount-label" class="block text-sm font-semibold text-gray-400 mb-1">取引金額 (円)</label>
                        <input type="number" id="trade-amount" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white" placeholder="例: 100000">
                    </div>
                    <div class="flex gap-4">
                        <button id="cancel-trade-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg">キャンセル</button>
                        <button id="confirm-trade-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">確定</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
            <div class="bg-gray-800 rounded-xl shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col border border-gray-700">
                <div class="flex justify-between items-center p-4 border-b border-gray-700"><h3 class="text-lg font-bold text-white">設定＆バックテスト</h3><button id="close-settings-modal" class="text-gray-400 hover:text-white text-2xl font-bold">&times;</button></div>
                <div class="p-6 overflow-y-auto text-gray-300 space-y-6">
                    <div>
                        <h3 class="text-xl font-bold text-white mb-4">分析ロジックのカスタマイズ</h3>
                        <div id="customization-form" class="space-y-4"></div>
                        <button id="save-settings-btn" class="mt-6 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">設定を保存</button>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold text-white mb-4">バックテスト (過去500件)</h3>
                        <p class="text-sm text-gray-400 mb-2">BTC/USDを基準に現在の設定でバックテストを実行します。</p>
                        <button id="run-backtest-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg mb-4 flex items-center justify-center">
                            <svg id="backtest-spinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                            バックテスト実行
                        </button>
                        <div id="backtest-results" class="hidden space-y-2 text-center bg-gray-900/50 p-4 rounded-lg"></div>
                    </div>
                </div>
            </div>
        </div>
        <div id="qa-modal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
            <div class="bg-gray-800 rounded-xl shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col border border-gray-700">
                <div class="flex justify-between items-center p-4 border-b border-gray-700"><h3 class="text-lg font-bold text-white">Q&A ヘルプ</h3><button id="close-qa-modal" class="text-gray-400 hover:text-white text-2xl font-bold">&times;</button></div>
                <div class="p-6 overflow-y-auto text-gray-300">
                    <h3 class="text-xl font-bold text-white mb-4">AIヘルプアシスタント</h3>
                    <p class="text-gray-400 mb-4">このツールや金融市場に関する質問を入力してください。</p>
                    <div class="flex gap-2">
                        <input type="text" id="qa-input" class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="例: 総合スコアって何？">
                        <button id="qa-submit" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">質問</button>
                    </div>
                    <div id="qa-response-container" class="mt-4 p-4 bg-gray-900/50 rounded-lg min-h-[100px]"></div>
                </div>
            </div>
        </div>
        <div id="notifications-modal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
            <div class="bg-gray-800 rounded-xl shadow-xl w-full max-w-md border border-gray-700">
                <div class="flex justify-between items-center p-4 border-b border-gray-700"><h3 class="text-lg font-bold text-white">通知設定</h3><button id="close-notifications-modal" class="text-gray-400 hover:text-white text-2xl font-bold">&times;</button></div>
                <div class="p-6 space-y-4 text-gray-300">
                    <div class="flex items-center justify-between">
                        <label for="desktop-notify-toggle">デスクトップ通知</label>
                        <label class="switch"><input type="checkbox" id="desktop-notify-toggle"><span class="slider"></span></label>
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="sound-notify-toggle">通知音</label>
                        <label class="switch"><input type="checkbox" id="sound-notify-toggle"><span class="slider"></span></label>
                    </div>
                    <div>
                        <label for="notify-threshold" class="block text-sm font-semibold mb-1">通知スコア閾値</label>
                        <input type="range" id="notify-threshold" min="4" max="10" step="0.5" class="w-full">
                        <p class="text-center text-sm text-gray-400">スコア <span id="notify-threshold-value"></span> 以上で通知</p>
                    </div>
                    <button id="save-notify-settings-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">設定を保存</button>
                </div>
            </div>
        </div>
        
        <!-- AI Model Modal -->
        <div id="ai-modal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
            <div class="bg-gray-800 rounded-xl shadow-xl w-full max-w-md border border-gray-700">
                <div class="flex justify-between items-center p-4 border-b border-gray-700"><h3 class="text-lg font-bold text-white">AIモデル分析 (Transformer)</h3><button id="close-ai-modal" class="text-gray-400 hover:text-white text-2xl font-bold">&times;</button></div>
                <div class="p-6 space-y-4 text-gray-300">
                    <p class="text-sm text-gray-400">現在のチャートパターンを基に、Transformerモデルが次の価格変動を予測します。(これはデモンストレーションです)</p>
                    <button id="run-ai-prediction" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center">
                         <svg id="ai-spinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                        AI予測を実行
                    </button>
                    <div id="ai-prediction-result" class="text-center mt-4 p-4 bg-gray-900/50 rounded-lg min-h-[80px]"></div>
                </div>
            </div>
        </div>

        <!-- Confirmation Modal -->
        <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
            <div class="bg-gray-800 rounded-xl shadow-xl w-full max-w-sm border border-gray-700">
                <div class="p-6 text-center space-y-4">
                    <h3 id="confirm-modal-title" class="text-xl font-bold text-white">確認</h3>
                    <p id="confirm-modal-text" class="text-gray-300"></p>
                    <div class="flex gap-4">
                        <button id="confirm-modal-cancel" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg">キャンセル</button>
                        <button id="confirm-modal-ok" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">OK</button>
                    </div>
                </div>
            </div>
        </div>

        <footer class="text-center mt-8 text-xs text-gray-500"><p>※これは投資助言ではありません。ご自身の判断で取引を行ってください。</p></footer>
    </div>
<script>
window.addEventListener('load', () => {
    // Creator Signature: Do not remove this line.
    const _appSignature = 'TklzaGltdXJhIFJ5dXRv';

    // ★★★ Connect to your secure Google Cloud backend ★★★
    // This is the URL of your deployed Cloud Run service.
    const CLOUD_FUNCTION_URL = 'https://crypto-tool-backend1-991185168999.asia-northeast1.run.app';


    // --- Element Declarations ---
    const runAnalysisBtn = document.getElementById('run-analysis');
    const loadingSpinner = document.getElementById('loading-spinner');
    const buttonText = document.getElementById('button-text');
    const autoRefreshToggle = document.getElementById('auto-refresh-toggle');
    const countdownTimerEl = document.getElementById('countdown-timer');
    const timeframeSelect = document.getElementById('timeframe-select');
    const optimizeIndicatorsBtn = document.getElementById('optimize-indicators');
    const optimizeSpinner = document.getElementById('optimize-spinner');
    const optimizationStatusEl = document.getElementById('optimization-status');

    const tabs = { 
        ranking: document.getElementById('tab-ranking'), 
        all: document.getElementById('tab-all'),
        history: document.getElementById('tab-history'),
        tradeHistory: document.getElementById('tab-trade-history') 
    };
    const panels = { 
        ranking: document.getElementById('ranking-panel'), 
        all: document.getElementById('all-pairs-panel'),
        history: document.getElementById('history-panel'),
        tradeHistory: document.getElementById('trade-history-panel')
    };
    const positionsSection = document.getElementById('positions-section');
    const positionsContainer = document.getElementById('positions-container');
    const accuracyRateEl = document.getElementById('accuracy-rate');
    const totalVerifiedEl = document.getElementById('total-verified');
    const successfulSignalsEl = document.getElementById('successful-signals');
    const failedSignalsEl = document.getElementById('failed-signals');
    const resetHistoryBtn = document.getElementById('reset-history-btn');
    const accuracyTooltipText = document.getElementById('accuracy-tooltip-text');
    const toastContainer = document.getElementById('toast-container');
    const dashboardMetersContainer = document.getElementById('dashboard-meters-container');
    const priceTickerContainer = document.getElementById('price-ticker-container');
    const quickPriceView = document.getElementById('quick-price-view');

    // Menu and Modals
    const headerMenu = document.getElementById('header-menu');
    const menuButton = document.getElementById('menu-button');
    const menuDropdown = document.getElementById('menu-dropdown');
    const menuSettings = document.getElementById('menu-settings');
    const menuAiAnalysis = document.getElementById('menu-ai-analysis');
    const menuQa = document.getElementById('menu-qa');
    const menuNotifications = document.getElementById('menu-notifications');
    const settingsModal = document.getElementById('settings-modal');
    const qaModal = document.getElementById('qa-modal');
    const aiModal = document.getElementById('ai-modal');
    const notificationsModal = document.getElementById('notifications-modal');
    const chartModal = document.getElementById('chart-modal');
    const closeSettingsModal = document.getElementById('close-settings-modal');
    const closeQaModal = document.getElementById('close-qa-modal');
    const closeAiModal = document.getElementById('close-ai-modal');
    const closeNotificationsModal = document.getElementById('close-notifications-modal');
    const closeChartModal = document.getElementById('close-chart-modal');
    const customizationForm = document.getElementById('customization-form');
    const saveSettingsBtn = document.getElementById('save-settings-btn');
    const runBacktestBtn = document.getElementById('run-backtest-btn');
    const backtestResultsEl = document.getElementById('backtest-results');
    const backtestSpinner = document.getElementById('backtest-spinner');
    const qaInput = document.getElementById('qa-input');
    const qaSubmitBtn = document.getElementById('qa-submit');
    const qaResponseContainer = document.getElementById('qa-response-container');
    const tradeEntryModal = document.getElementById('trade-entry-modal');
    const tradeEntryTitle = document.getElementById('trade-entry-title');
    const tradeAmountInput = document.getElementById('trade-amount');
    const tradeAmountLabel = document.getElementById('trade-amount-label');
    const cancelTradeBtn = document.getElementById('cancel-trade-btn');
    const confirmTradeBtn = document.getElementById('confirm-trade-btn');
    const desktopNotifyToggle = document.getElementById('desktop-notify-toggle');
    const soundNotifyToggle = document.getElementById('sound-notify-toggle');
    const notifyThresholdInput = document.getElementById('notify-threshold');
    const notifyThresholdValue = document.getElementById('notify-threshold-value');
    const saveNotifySettingsBtn = document.getElementById('save-notify-settings-btn');
    const chartTimeframeSelector = document.getElementById('chart-timeframe-selector');
    const chartLoadingOverlay = document.getElementById('chart-loading-overlay');
    const confirmModal = document.getElementById('confirm-modal');
    const confirmModalTitle = document.getElementById('confirm-modal-title');
    const confirmModalText = document.getElementById('confirm-modal-text');
    const confirmModalCancel = document.getElementById('confirm-modal-cancel');
    const confirmModalOk = document.getElementById('confirm-modal-ok');
    const runAiPredictionBtn = document.getElementById('run-ai-prediction');
    const aiSpinner = document.getElementById('ai-spinner');
    const aiPredictionResultEl = document.getElementById('ai-prediction-result');
    const advancedStatsContainer = document.getElementById('advanced-stats-container');
    const conditionWiseStatsEl = document.getElementById('condition-wise-stats');
    const winRateTrendChartCanvas = document.getElementById('win-rate-trend-chart');


    // --- State Variables ---
    const ASSET_CONFIGS = [
        { pair: 'BTC/USD', fsym: 'BTC', tsym: 'USD', type: 'crypto' },
        { pair: 'ETH/USD', fsym: 'ETH', tsym: 'USD', type: 'crypto' },
        { pair: 'USD/JPY', fsym: 'USD', tsym: 'JPY', type: 'forex' },
        { pair: 'EUR/USD', fsym: 'EUR', tsym: 'USD', type: 'forex' },
        { pair: 'GBP/JPY', fsym: 'GBP', tsym: 'JPY', type: 'forex' },
        { pair: 'XRP/USD', fsym: 'XRP', tsym: 'USD', type: 'crypto' },
        { pair: 'SOL/USD', fsym: 'SOL', tsym: 'USD', type: 'crypto' },
        { pair: 'ADA/USD', fsym: 'ADA', tsym: 'USD', type: 'crypto' },
        { pair: 'DOGE/USD', fsym: 'DOGE', tsym: 'USD', type: 'crypto' },
        { pair: 'LINK/USD', fsym: 'LINK', tsym: 'USD', type: 'crypto' },
        { pair: 'XAUT/USD', fsym: 'XAUT', tsym: 'USD', type: 'crypto' },
    ];
    let autoRefreshInterval = null;
    let countdownInterval = null;
    let openPositions = JSON.parse(localStorage.getItem('openPositions')) || {};
    let signalHistory = JSON.parse(localStorage.getItem('signalHistory')) || [];
    let analysisHistory = JSON.parse(localStorage.getItem('analysisHistory')) || [];
    let tradeHistory = JSON.parse(localStorage.getItem('tradeHistory')) || [];
    let currentAnalysisScores = {};
    let jpyRate = 150; // Default rate, will be updated
    let audioContext;
    let lastNotifiedSignal = {};
    let chartInstance = null;
    let winRateChartInstance = null;
    
    // Default settings object, can be overridden by timeframeConfigs
    let baseAnalysisSettings = JSON.parse(localStorage.getItem('analysisSettings')) || {
        weights: { 
            ma: 1.0, macd: 1.0, rsi: 1.0, stoch: 1.0, bb: 1.0, ichimoku: 1.5, vwap: 1.2, chartPatterns: 2.0, psar: 1.5,
            mtaConfirmation: 2.0, volumeConfirmation: 1.5, divergence: 3.0, sentiment: 2.5,
            maSlope: 1.2, mtaAlignment: 3.0,
            fibonacci: 1.8,
            pivot: 1.7,
            elderImpulse: 2.2, // New weight for Elder Impulse System
            squeeze: 2.5, obvDivergence: 2.0,
            cci: 1.5, atrVolatility: 1.2 // ★ 為替・ゴールド分析用に新規追加
        },
        params: {
            rsiPeriod: 14, rsiOverbought: 70, rsiOversold: 30,
            stochPeriod: 14, stochOverbought: 80, stochOversold: 20,
            bbPeriod: 20, bbStdDev: 2,
            emaShort: 12, emaLong: 26, smaShort: 20, smaLong: 50, macdSignal: 9,
            tenkan: 9, kijun: 26, senkouB: 52,
            psarStart: 0.02, psarIncrement: 0.02, psarMax: 0.2,
            signalThreshold: 3.5,
            adxPeriod: 14, adxThreshold: 25,
            volumeSpikeMultiplier: 2.0,
            divergenceLookback: 40, 
            divergenceOffset: 5,
            atrPeriod: 14,
            slopePeriod: 10,
            // New params for new features
            bbwSqueezeLookback: 50, bbwSqueezeThreshold: 0.1,
            keltnerPeriod: 20, keltnerMultiplier: 1.5,
            cciPeriod: 20, atrVolatilityThreshold: 1.5 // ★ 為替・ゴールド分析用に新規追加
        }
    };

    // --- Timeframe-specific configurations ---
    const timeframeConfigs = {
        'minute': {
            label: '1分足', endpoint: 'histominute', aggregate: 1, limit: 240, verificationPeriod: 30, // in bars
            mta: [{key: '5minute', weight: 0.6}, {key: '15minute', weight: 0.4}],
            params: { ...baseAnalysisSettings.params, rsiPeriod: 9, emaShort: 9, emaLong: 21 },
            weights: { ...baseAnalysisSettings.weights },
            useEMA: true
        },
        '5minute': {
            label: '5分足', endpoint: 'histominute', aggregate: 5, limit: 96, verificationPeriod: 12, // in bars
            mta: [{key: '15minute', weight: 0.7}, {key: 'hour', weight: 0.3}],
            params: { ...baseAnalysisSettings.params, rsiPeriod: 9, emaShort: 9, emaLong: 21 },
            weights: { ...baseAnalysisSettings.weights },
            useEMA: true
        },
        '15minute': {
            label: '15分足', endpoint: 'histominute', aggregate: 15, limit: 96, verificationPeriod: 16, // in bars
            mta: [{key: 'hour', weight: 0.8}, {key: '4hour', weight: 0.2}],
            params: { ...baseAnalysisSettings.params },
            weights: { ...baseAnalysisSettings.weights, bb: 1.8, volumeConfirmation: 2.0 }, // Emphasize BB and Volume
            useEMA: false // Use SMA
        },
        'hour': {
            label: '1時間足', endpoint: 'histohour', aggregate: 1, limit: 168, verificationPeriod: 12, // in bars
            mta: [{key: '4hour', weight: 0.7}, {key: 'day', weight: 0.3}],
            params: { ...baseAnalysisSettings.params },
            weights: { ...baseAnalysisSettings.weights, ichimoku: 2.5 }, // Emphasize Ichimoku
            useEMA: true
        },
        '4hour': {
            label: '4時間足', endpoint: 'histohour', aggregate: 4, limit: 180, verificationPeriod: 12, // in bars
            mta: [{key: 'day', weight: 1.0}],
            params: { ...baseAnalysisSettings.params, emaShort: 21, emaLong: 50 },
            weights: { ...baseAnalysisSettings.weights, psar: 2.0, ma: 1.5 }, // Emphasize PSAR and MAs
            useEMA: true
        },
        'day': {
            label: '日足', endpoint: 'histoday', aggregate: 1, limit: 200, verificationPeriod: 7, // in bars
            mta: [], // No higher timeframe analysis needed for daily
            params: { ...baseAnalysisSettings.params },
            weights: { ...baseAnalysisSettings.weights, ichimoku: 2.0, macd: 1.5 },
            useEMA: true
        },
    };

    let notificationSettings = JSON.parse(localStorage.getItem('notificationSettings')) || {
        desktop: true,
        sound: true,
        threshold: 8.0
    };
    const dataCache = new Map();

    const dataHealthMonitor = {
      failures: {},
      recordFailure(asset, timeframe) {
        const key = `${asset}-${timeframe}`;
        this.failures[key] = (this.failures[key] || 0) + 1;
      },
      recordSuccess(asset, timeframe) {
        const key = `${asset}-${timeframe}`;
        this.failures[key] = 0;
      },
      isUnhealthy(asset, timeframe) {
        const key = `${asset}-${timeframe}`;
        return (this.failures[key] || 0) > 3;
      },
      getHealthStatus() {
        return Object.keys(this.failures).filter(k => this.failures[k] > 0)
          .map(k => ({ pair: k, failures: this.failures[k] }));
      }
    };

    // --- Utility Functions ---
    const createToast = (message, type = 'info') => {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        toastContainer.appendChild(toast);
        setTimeout(() => toast.remove(), 5000);
    };
    
    const delay = ms => new Promise(res => setTimeout(res, ms));

    function handleError(error, context) {
        console.error(`Error in ${context}:`, error);
        const errorMessage = error.message || '不明なエラー';
        createToast(`${context}でエラーが発生: ${errorMessage}`, 'error');

        if (error.message.toLowerCase().includes('rate limit')) {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                clearInterval(countdownInterval);
                autoRefreshToggle.checked = false;
                countdownTimerEl.textContent = '';
                runAnalysisBtn.disabled = false;
                createToast('API制限のため自動更新を停止しました', 'error');
            }
        }
    }

    function getConfidenceLevel(score) {
        const absScore = Math.abs(score);
        if (absScore >= 8.5) return { rank: 'S', class: 'confidence-S' };
        if (absScore >= 7.5) return { rank: 'A+', class: 'confidence-APlus' };
        if (absScore >= 6.5) return { rank: 'A', class: 'confidence-A' };
        if (absScore >= 5.5) return { rank: 'B', class: 'confidence-B' };
        return { rank: 'C', class: 'confidence-C' };
    }

    // --- Core Functions ---
    async function fetchWithCache(url, cacheKey, expiry = 60000) {
        const now = Date.now();
        if (dataCache.has(cacheKey)) {
            const { data, timestamp } = dataCache.get(cacheKey);
            if (now - timestamp < expiry) return data;
        }
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(errorText || `API Error: ${response.status}`);
            }
            const data = await response.json();
            if (data.Response === 'Error') {
                throw new Error(data.Message);
            }
            dataCache.set(cacheKey, { data, timestamp: now });
            return data;
        } catch (error) {
            handleError(error, `API Call to ${url.substring(0, 80)}...`);
            return null;
        }
    }

    async function fetchWithRetry(url, cacheKey, expiry = 60000, maxRetries = 3) {
      let lastError;
      for (let i = 0; i < maxRetries; i++) {
        try {
          const data = await fetchWithCache(url, cacheKey, expiry);
          if (data) return data;
          // No explicit 'No data received' error needed, as fetchWithCache handles API errors.
        } catch (error) {
          lastError = error;
          console.warn(`Attempt ${i + 1} failed for ${url.substring(0, 80)}, retrying...`, error);
          await delay(1000 * Math.pow(2, i));
        }
      }
      if (lastError) throw lastError;
      return null;
    }

    async function fetchData(fsym, tsym, endpoint, limit = 200, aggregate = 1) {
        const aggParam = aggregate > 1 ? `&aggregate=${aggregate}` : '';
        const url = `${CLOUD_FUNCTION_URL}/proxy/v2/${endpoint}?fsym=${fsym}&tsym=${tsym}&limit=${limit}${aggParam}`;
        const cacheKey = `${fsym}-${tsym}-${endpoint}-${limit}-${aggregate}`;
        
        const cacheExpiry = {
            'histominute': 60000,
            'histohour': 300000,
            'histoday': 3600000,
        };
        const expiry = cacheExpiry[endpoint] || 300000;
        
        try {
            const data = await fetchWithRetry(url, cacheKey, expiry);
            dataHealthMonitor.recordSuccess(`${fsym}/${tsym}`, endpoint);
            return data ? data.Data.Data : null;
        } catch (error) {
            dataHealthMonitor.recordFailure(`${fsym}/${tsym}`, endpoint);
            console.error(`Failed to fetch data after retries for ${fsym}/${tsym}`, error);
            return null;
        }
    }

    function ensureSufficientData(data, minLength) {
      if (!data || data.length < minLength) {
        console.warn(`Insufficient data (${data ? data.length : 0}), generating fallback data.`);
        const fallbackData = [];
        const lastValue = data && data.length > 0 ? data[data.length - 1] : { 
          time: Math.floor(Date.now() / 1000), 
          close: 100, high: 105, low: 95, open: 100, volume: 1000 
        };
        
        const timeUnit = 3600; // Default to hourly
        for (let i = 0; i < minLength; i++) {
          fallbackData.push({ ...lastValue, time: lastValue.time - (minLength - i - 1) * timeUnit });
        }
        return fallbackData;
      }
      return data;
    }

    async function fetchCurrentPrice(configs) {
        const requestsByTsym = {};
        configs.forEach(config => {
            if (!requestsByTsym[config.tsym]) {
                requestsByTsym[config.tsym] = [];
            }
            requestsByTsym[config.tsym].push(config.fsym);
        });

        let finalData = {};
        for (const tsym in requestsByTsym) {
            const fsyms = requestsByTsym[tsym];
            const url = `${CLOUD_FUNCTION_URL}/proxy/pricemultifull?fsyms=${fsyms.join(',')}&tsyms=${tsym}`;
            const cacheKey = `pricemultifull-${fsyms.join(',')}-${tsym}`;
            const data = await fetchWithCache(url, cacheKey, 10000); // 10s cache
            if (data && data.RAW) {
                for (const fsym in data.RAW) {
                    if (!finalData[fsym]) finalData[fsym] = {};
                    finalData[fsym][tsym] = data.RAW[fsym][tsym];
                }
            }
        }
        return Object.keys(finalData).length > 0 ? finalData : null;
    }
    
    async function updateJpyRate() {
        const url = `${CLOUD_FUNCTION_URL}/proxy/price?fsym=USD&tsyms=JPY`;
        const cacheKey = 'jpy-rate';
        const data = await fetchWithCache(url, cacheKey, 3600000); // 1 hour cache
        if (data && data.JPY) jpyRate = data.JPY;
    }

    async function fetchSentimentData() {
        const cryptoSymbols = ASSET_CONFIGS.filter(c => c.type === 'crypto').map(c => c.fsym);
        if(cryptoSymbols.length === 0) return null;

        const url = `${CLOUD_FUNCTION_URL}/proxy/v2/news/?categories=${cryptoSymbols.join(',')}&lang=EN`;
        const cacheKey = `sentiment-${cryptoSymbols.join(',')}`;
        const data = await fetchWithCache(url, cacheKey, 1800000); // 30 min cache
        return data ? data.Data : null;
    }

    async function performAnalysis(showResults = true) {
        if (showResults) {
            runAnalysisBtn.disabled = true;
            loadingSpinner.classList.remove('hidden');
            buttonText.textContent = '分析中...';
            panels.ranking.innerHTML = '<div class="text-center text-gray-400 p-8">分析データを取得中...</div>';
            panels.all.innerHTML = '';
        }

        const selectedTimeframe = timeframeSelect.value;
        updateAccuracyTooltip(selectedTimeframe);
        
        // --- OPTIMIZATION: Fetch all sentiment data at once for crypto ---
        const allSentimentData = await fetchSentimentData();
        const sentimentByPair = {};
        if (allSentimentData) {
            allSentimentData.forEach(article => {
                const pairsInArticle = article.categories.split(',');
                pairsInArticle.forEach(pair => {
                    if (ASSET_CONFIGS.find(c => c.fsym === pair)) {
                        if (!sentimentByPair[pair]) sentimentByPair[pair] = [];
                        sentimentByPair[pair].push(article);
                    }
                });
            });
        }
        
        // ★★★ START: 全アセットの分析を並列実行するように変更 ★★★
        const analysisPromises = ASSET_CONFIGS.map(assetConfig => {
            // Sentiment data is only for crypto
            const pairSentiment = assetConfig.type === 'crypto' ? sentimentByPair[assetConfig.fsym] || [] : null;
            return runRealAnalysis(assetConfig, selectedTimeframe, pairSentiment);
        });

        const allResults = (await Promise.all(analysisPromises)).filter(Boolean); // filter out null/failed results
        // ★★★ END: 全アセットの分析を並列実行するように変更 ★★★

        if (allResults.length > 0) {
            if (showResults) {
                const report = { timestamp: Date.now(), results: allResults, timeframe: selectedTimeframe };
                analysisHistory.unshift(report);
                if (analysisHistory.length > 20) analysisHistory.pop();
                localStorage.setItem('analysisHistory', JSON.stringify(analysisHistory));
                populateHistoryPanel();

                allResults.sort((a, b) => Math.abs(b.score) - Math.abs(a.score));
                const top3Results = allResults.slice(0, 3);
                
                panels.ranking.innerHTML = '';
                top3Results.forEach((result, index) => {
                    panels.ranking.appendChild(createReportCard(result, index + 1, selectedTimeframe));
                });
                
                panels.all.innerHTML = '';
                allResults.forEach(result => {
                    panels.all.appendChild(createReportCard(result, null, selectedTimeframe));
                });
                
                updateDashboardMeters(top3Results);

                const topSignal = allResults[0];
                if (topSignal && Math.abs(topSignal.score) >= notificationSettings.threshold && lastNotifiedSignal[topSignal.assetConfig.pair] !== topSignal.signal) {
                    if (notificationSettings.sound) playNotificationSound();
                    if (notificationSettings.desktop) showDesktopNotification(topSignal.assetConfig.pair, topSignal.signal, topSignal.score);
                    lastNotifiedSignal[topSignal.assetConfig.pair] = topSignal.signal;
                }
            }
        } else if (showResults) {
            panels.ranking.innerHTML = `<div class="text-center text-gray-500 py-10 bg-gray-800/50 rounded-xl"><p>有効な分析結果を取得できませんでした。APIのレート制限に達した可能性があります。</p></div>`;
            dashboardMetersContainer.innerHTML = `<div class="text-center text-gray-500 py-10 col-span-3"><p>分析結果がありません。</p></div>`;
        }

        if (showResults) {
            runAnalysisBtn.disabled = false;
            loadingSpinner.classList.add('hidden');
            buttonText.textContent = '総合分析を実行';
        }
    }
    
    function updateDashboardMeters(topResults) {
        dashboardMetersContainer.innerHTML = '';
        if (topResults.length === 0) {
            dashboardMetersContainer.innerHTML = `<div class="text-center text-gray-500 py-10 col-span-3"><p>分析結果がありません。</p></div>`;
            return;
        }
        topResults.forEach(result => {
            const meterEl = document.createElement('div');
            meterEl.className = 'flex flex-col items-center bg-gray-700/50 p-4 rounded-lg';
            meterEl.innerHTML = `
                <h3 class="text-lg font-semibold text-white mb-2">${result.assetConfig.pair}</h3>
                <div class="meter-container">
                    <div class="meter-bg"></div>
                    <div class="meter-value"></div>
                    <div id="meter-pointer-${result.assetConfig.fsym}${result.assetConfig.tsym}" class="meter-pointer"></div>
                    <div class="meter-center"></div>
                </div>
                <p id="sentiment-text-${result.assetConfig.fsym}${result.assetConfig.tsym}" class="mt-2 font-bold text-lg text-white">分析中...</p>
            `;
            dashboardMetersContainer.appendChild(meterEl);

            const score = result.score;
            const angle = Math.max(-90, Math.min(90, score * 9));
            document.getElementById(`meter-pointer-${result.assetConfig.fsym}${result.assetConfig.tsym}`).style.transform = `rotate(${angle}deg)`;
            const sentimentTextEl = document.getElementById(`sentiment-text-${result.assetConfig.fsym}${result.assetConfig.tsym}`);
            
            if (score > 3) { sentimentTextEl.textContent = "強い買い"; sentimentTextEl.className = "mt-2 font-bold text-lg text-green-400"; } 
            else if (score > 1) { sentimentTextEl.textContent = "買い優勢"; sentimentTextEl.className = "mt-2 font-bold text-lg text-green-300"; } 
            else if (score < -3) { sentimentTextEl.textContent = "強い売り"; sentimentTextEl.className = "mt-2 font-bold text-lg text-red-400"; } 
            else if (score < -1) { sentimentTextEl.textContent = "売り優勢"; sentimentTextEl.className = "mt-2 font-bold text-lg text-red-300"; } 
            else { sentimentTextEl.textContent = "中立"; sentimentTextEl.className = "mt-2 font-bold text-lg text-yellow-400"; }
        });
    }

    // --- Confirmation Modal Logic ---
    function showConfirmation(title, text, onOk) {
        confirmModalTitle.textContent = title;
        confirmModalText.textContent = text;
        confirmModal.classList.remove('hidden');

        confirmModalCancel.onclick = () => {
            confirmModal.classList.add('hidden');
        };

        confirmModalOk.onclick = () => {
            confirmModal.classList.add('hidden');
            onOk();
        };
    }

    // --- New Feature: Indicator Optimization ---
    async function runSimpleBacktest(data, timeframeKey, tempSettings) {
        let pnl = 0;
        let openTrade = null;
        let tradeCount = 0;
        const config = timeframeConfigs[timeframeKey];
        const initialInvestment = 100; // Assume 100 USD initial investment for PnL calculation
        const btcConfig = ASSET_CONFIGS.find(c => c.pair === 'BTC/USD');

        for (let i = config.limit; i < data.length; i++) {
            const currentData = data.slice(0, i);
            const result = await performFullTechnicalAnalysis(btcConfig, timeframeKey, currentData, true, tempSettings, null, null);

            if (openTrade) {
                // Exit condition: signal reverses
                if (result.signal !== 'hold' && result.signal !== openTrade.signal) {
                    const profit = (result.currentPrice - openTrade.entryPrice) * (openTrade.signal === 'buy' ? 1 : -1);
                    pnl += (profit / openTrade.entryPrice);
                    openTrade = null;
                }
            }

            // Entry condition
            if (!openTrade && result.signal !== 'hold') {
                openTrade = {
                    signal: result.signal,
                    entryPrice: result.currentPrice
                };
                tradeCount++;
            }
        }
        return { netProfit: pnl * initialInvestment, tradeCount }; // Return profit based on initial investment
    }

    // ★★★ START: 最適化レベルのプリセットを追加 ★★★
    const optimizationPresets = {
        'fast': { name: '高速（1分）', populationSize: 8, generations: 4, sampleRate: 30, dataPoints: 500, paramKeys: ['rsiPeriod', 'emaShort', 'emaLong', 'signalThreshold'] },
        'balanced': { name: 'バランス（3分）', populationSize: 12, generations: 6, sampleRate: 20, dataPoints: 800, paramKeys: ['rsiPeriod', 'emaShort', 'emaLong', 'signalThreshold', 'stochPeriod', 'bbPeriod'] },
        'thorough': { name: '詳細（10分）', isThorough: true }
    };
    // ★★★ END: 最適化レベルのプリセットを追加 ★★★

    async function runOptimization() {
        // ★★★ START: 最適化関数のUI/UXを大幅に改善 ★★★
        const level = document.getElementById('optimization-level-select').value;
        const preset = optimizationPresets[level];
        
        optimizeIndicatorsBtn.disabled = true;
        runAnalysisBtn.disabled = true;
        optimizeSpinner.classList.remove('hidden');
        
        // プログレス表示UIを生成
        optimizationStatusEl.innerHTML = `
            <div class="mt-2">
                <div class="w-full bg-gray-700 rounded-full h-2.5">
                    <div id="optimization-progress-bar" class="bg-green-500 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <div class="flex justify-between text-xs text-gray-400 mt-1">
                    <span id="optimization-progress-text">初期化中...</span>
                    <span id="optimization-time-estimate">残り時間: 計算中...</span>
                </div>
            </div>
        `;

        try {
            if (preset.isThorough) {
                // 詳細最適化の呼び出し（将来的な拡張用）
                await runThoroughOptimization(); 
            } else {
                await runFastGeneticOptimization(preset);
            }
        } catch (error) {
            console.error("最適化中にエラーが発生しました:", error);
            createToast('最適化中にエラーが発生しました。', 'error');
            optimizationStatusEl.textContent = 'エラーが発生しました。';
        } finally {
            optimizeSpinner.classList.add('hidden');
            optimizeIndicatorsBtn.disabled = false;
            runAnalysisBtn.disabled = false;
        }
        // ★★★ END: 最適化関数のUI/UXを大幅に改善 ★★★
    }

    // ★★★ START: 既存の最適化関数を'runThoroughOptimization'にリネーム ★★★
    async function runThoroughOptimization() {
    // ★★★ END: リネーム ★★★
        optimizeIndicatorsBtn.disabled = true;
        runAnalysisBtn.disabled = true;
        optimizeSpinner.classList.remove('hidden');
        optimizationStatusEl.textContent = '詳細最適化プロセスを開始...';
        createToast('詳細な指標最適化を開始しました。完了まで数分かかることがあります。', 'info');

        const timeframeKey = timeframeSelect.value;
        const config = timeframeConfigs[timeframeKey];
        
        // 複数の代表銘柄で最適化を行う
        const optimizationPairs = [
            ASSET_CONFIGS.find(c => c.pair === 'BTC/USD'),
            ASSET_CONFIGS.find(c => c.pair === 'ETH/USD'),
            ASSET_CONFIGS.find(c => c.pair === 'USD/JPY')
        ].filter(Boolean);

        // より長期間のデータを取得
        const allData = {};
        for (const assetConfig of optimizationPairs) {
            const data = await fetchData(assetConfig.fsym, assetConfig.tsym, config.endpoint, 2000, config.aggregate);
            if (data && data.length >= 1000) {
                allData[assetConfig.pair] = data;
            }
        }

        if (Object.keys(allData).length === 0) {
            createToast('最適化のためのデータが不足しています。', 'error');
            optimizeIndicatorsBtn.disabled = false;
            runAnalysisBtn.disabled = false;
            optimizeSpinner.classList.add('hidden');
            optimizationStatusEl.textContent = '最適化に失敗しました。';
            return;
        }

        // パラメータ範囲の拡大
        const paramRanges = {
            rsiPeriod: [7, 9, 14, 21, 28],
            emaShort: [5, 9, 12, 15, 20],
            emaLong: [20, 26, 30, 40, 50],
            signalThreshold: [2.5, 3.0, 3.5, 4.0, 4.5],
            bbPeriod: [14, 20, 26, 30],
            bbStdDev: [1.5, 2.0, 2.5],
            stochPeriod: [7, 14, 21],
            adxPeriod: [10, 14, 20]
        };

        // 遺伝的アルゴリズムによる効率的なパラメータ探索
        const populationSize = 20;
        const generations = 10;
        let population = initializePopulation(populationSize, paramRanges);
        
        let bestParams = { ...baseAnalysisSettings.params };
        let bestPerformance = -Infinity;
        let bestResults = {};
        
        // 最適化プログレス表示の準備
        const progressContainer = document.createElement('div');
        progressContainer.id = 'optimization-progress-container';
        progressContainer.className = 'mt-4 p-4 bg-gray-900/50 rounded-lg';
        progressContainer.innerHTML = `
            <h4 class="text-sm font-semibold text-gray-300 mb-2">最適化進捗</h4>
            <div class="w-full bg-gray-700 rounded-full h-2.5 mb-2">
                <div id="ga-progress-bar" class="bg-green-500 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
            <div class="flex justify-between text-xs text-gray-400">
                <span id="ga-generation">世代: 0/${generations}</span>
                <span id="ga-best-score">最高スコア: -</span>
            </div>
            <div id="ga-params-display" class="mt-2 text-xs text-gray-400 ga-params-display"></div>
        `;
        document.querySelector('.control-panel').appendChild(progressContainer);
        
        // 遺伝的アルゴリズムの実行
        for (let gen = 0; gen < generations; gen++) {
            updateProgress(gen, generations, 0, populationSize);
            
            const evaluatedPopulation = [];
            for (let i = 0; i < population.length; i++) {
                updateProgress(gen, generations, i + 1, populationSize);
                
                const individual = population[i];
                let totalScore = 0;
                const individualResults = {};
                
                for (const pair in allData) {
                    const assetConfig = optimizationPairs.find(c => c.pair === pair);
                    const result = await evaluateParameters(individual, allData[pair], { ...config, timeframeKey }, assetConfig);
                    totalScore += result.score;
                    individualResults[pair] = result;
                }
                
                const avgScore = totalScore / Object.keys(allData).length;
                evaluatedPopulation.push({ params: individual, score: avgScore, results: individualResults });
                
                if (avgScore > bestPerformance) {
                    bestPerformance = avgScore;
                    bestParams = { ...individual };
                    bestResults = individualResults;
                    updateBestScoreDisplay(bestPerformance, bestParams);
                }
                await delay(10);
            }
            
            population = createNextGeneration(evaluatedPopulation, paramRanges);
            
            document.getElementById('ga-generation').textContent = `世代: ${gen + 1}/${generations}`;
        }
        
        baseAnalysisSettings.params = bestParams;
        localStorage.setItem('analysisSettings', JSON.stringify(baseAnalysisSettings));
        populateSettingsForm();
        
        displayOptimizationResults(bestPerformance, bestResults, optimizationPairs);
        
        progressContainer.remove();
        optimizeSpinner.classList.add('hidden');
        optimizeIndicatorsBtn.disabled = false;
        runAnalysisBtn.disabled = false;
    }

    async function evaluateParameters(params, data, config, assetConfig) {
        const initialInvestment = 1000;
        let equity = initialInvestment;
        let peakEquity = initialInvestment;
        let maxDrawdown = 0;
        let trades = 0;
        let winningTrades = 0;
        let openTrade = null;
        const returns = [];
        
        for (let i = config.limit; i < data.length - 1; i++) {
            const currentData = data.slice(0, i + 1);
            let tempSettings = { ...baseAnalysisSettings, params: params };
            const result = await performFullTechnicalAnalysis(assetConfig, config.timeframeKey, currentData, true, tempSettings, null, null);
            
            if (!result) continue;
            
            if (openTrade) {
                const entryPrice = openTrade.entryPrice;
                const exitPrice = data[i + 1].open; // 前方覗きを修正: 次のバーの始値で決済
                const exitSignal = result.signal !== 'hold' && result.signal !== openTrade.signal;
                
                if (exitSignal) {
                    // 取引コストの考慮
                    const spread = 0.0005; // 0.05%
                    const commission = 0.001; // 0.1%
                    const effectiveEntryPrice = openTrade.signal === 'buy' ? entryPrice * (1 + spread) : entryPrice * (1 - spread);
                    const effectiveExitPrice = openTrade.signal === 'buy' ? exitPrice * (1 - spread) : exitPrice * (1 + spread);
                    const cost = (effectiveEntryPrice * commission) + (effectiveExitPrice * commission);
                    const pnl = ((effectiveExitPrice - effectiveEntryPrice) * (openTrade.signal === 'buy' ? 1 : -1)) - cost;

                    equity += pnl;
                    returns.push((equity / (equity - pnl)) - 1);
                    trades++;
                    if (pnl > 0) winningTrades++;
                    
                    if (equity > peakEquity) peakEquity = equity;
                    const drawdown = ((peakEquity - equity) / peakEquity);
                    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
                    
                    openTrade = null;
                }
            }
            
            if (!openTrade && result.signal !== 'hold') {
                openTrade = {
                    signal: result.signal,
                    entryPrice: data[i].close, // 現在のバーの終値でエントリー
                };
            }
        }
        
        const totalReturn = ((equity - initialInvestment) / initialInvestment) * 100;
        const winRate = trades > 0 ? (winningTrades / trades) * 100 : 0;
        
        const avgReturn = returns.length > 0 ? returns.reduce((a, b) => a + b, 0) / returns.length : 0;
        const stdDev = returns.length > 0 ? Math.sqrt(returns.map(x => Math.pow(x - avgReturn, 2)).reduce((a, b) => a + b, 0) / returns.length) : 0;
        const sharpeRatio = stdDev > 0 ? (avgReturn / stdDev) * Math.sqrt(252) : 0; // Annualized
        
        const score = calculateCompositeScore(totalReturn, winRate, sharpeRatio, maxDrawdown * 100, trades);
        
        return { score, totalReturn, winRate, sharpeRatio, maxDrawdown: maxDrawdown * 100, trades };
    }

    function calculateCompositeScore(totalReturn, winRate, sharpeRatio, maxDrawdown, trades) {
      // トレード数が少ない場合はペナルティ
      if (trades < 10) return -100;
      
      // 各種指標をバランスよく考慮
      const returnScore = Math.min(100, totalReturn) * 0.3;
      const winRateScore = winRate * 0.2;
      const sharpeScore = Math.max(0, sharpeRatio) * 10 * 0.25;
      const drawdownScore = Math.max(0, 30 - maxDrawdown) * 0.25; // ドローダウンが小さいほど高得点
      
      return returnScore + winRateScore + sharpeScore + drawdownScore;
    }

    function initializePopulation(size, paramRanges) {
        const population = [];
        for (let i = 0; i < size; i++) {
            const individual = {};
            for (const [param, values] of Object.entries(paramRanges)) {
                individual[param] = values[Math.floor(Math.random() * values.length)];
            }
            population.push(individual);
        }
        return population;
    }

    function createNextGeneration(evaluatedPopulation, paramRanges) {
        evaluatedPopulation.sort((a, b) => b.score - a.score);
        const newPopulation = [];
        const eliteCount = Math.floor(evaluatedPopulation.length * 0.2);
        
        for (let i = 0; i < eliteCount; i++) {
            newPopulation.push(evaluatedPopulation[i].params);
        }
        
        while (newPopulation.length < evaluatedPopulation.length) {
            const parent1 = tournamentSelection(evaluatedPopulation, 3);
            const parent2 = tournamentSelection(evaluatedPopulation, 3);
            const child = crossover(parent1, parent2);
            mutate(child, paramRanges, 0.1);
            newPopulation.push(child);
        }
        return newPopulation;
    }

    function tournamentSelection(population, tournamentSize) {
        let best = null;
        for (let i = 0; i < tournamentSize; i++) {
            const candidate = population[Math.floor(Math.random() * population.length)];
            if (!best || candidate.score > best.score) best = candidate;
        }
        return best.params;
    }

    function crossover(parent1, parent2) {
        const child = {};
        for (const param in parent1) {
            child[param] = Math.random() < 0.5 ? parent1[param] : parent2[param];
        }
        return child;
    }

    function mutate(individual, paramRanges, mutationRate) {
        for (const [param, values] of Object.entries(paramRanges)) {
            if (Math.random() < mutationRate) {
                individual[param] = values[Math.floor(Math.random() * values.length)];
            }
        }
    }

    function updateProgress(generation, totalGenerations, individual, populationSize) {
        const totalProgress = ((generation * populationSize + individual) / (totalGenerations * populationSize)) * 100;
        const progressBar = document.getElementById('ga-progress-bar');
        if(progressBar) progressBar.style.width = `${totalProgress}%`;
        optimizationStatusEl.textContent = `最適化中: 世代 ${generation + 1}/${totalGenerations}, 個体 ${individual}/${populationSize}`;
    }

    function updateBestScoreDisplay(score, params) {
        const bestScoreEl = document.getElementById('ga-best-score');
        const paramsDisplayEl = document.getElementById('ga-params-display');
        if(!bestScoreEl || !paramsDisplayEl) return;

        bestScoreEl.textContent = `最高スコア: ${score.toFixed(2)}`;
        let paramsText = "";
        for (const [key, value] of Object.entries(params)) {
            paramsText += `${key}: ${value} `;
        }
        paramsDisplayEl.textContent = `最適パラメータ: ${paramsText}`;
    }

    function displayOptimizationResults(bestParams, inSample, outOfSample, assetConfig) {
        let resultsHTML = `<div class="mt-4 p-4 bg-gray-900/50 rounded-lg">
            <h4 class="text-lg font-semibold text-green-400 mb-2">ウォークフォワード最適化完了！</h4>
            <p class="text-sm text-gray-300">最適化銘柄: <span class="font-bold">${assetConfig.pair}</span></p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-3">
                <div class="bg-gray-800 p-3 rounded-lg">
                    <h5 class="font-semibold text-white">In-Sample (最適化期間)</h5>
                    <p class="text-xs text-gray-400">利益率: <span class="${inSample.totalReturn >= 0 ? 'text-green-400' : 'text-red-400'}">${inSample.totalReturn.toFixed(2)}%</span></p>
                    <p class="text-xs text-gray-400">勝率: ${inSample.winRate.toFixed(1)}%</p>
                    <p class="text-xs text-gray-400">シャープレシオ: ${inSample.sharpeRatio.toFixed(2)}</p>
                    <p class="text-xs text-gray-400">最大DD: ${inSample.maxDrawdown.toFixed(1)}%</p>
                    <p class="text-xs text-gray-400">トレード数: ${inSample.trades}</p>
                </div>
                <div class="bg-gray-800 p-3 rounded-lg border-2 ${outOfSample.totalReturn > 0 ? 'border-green-500' : 'border-red-500'}">
                    <h5 class="font-semibold text-white">Out-of-Sample (検証期間)</h5>
                    <p class="text-xs text-gray-400">利益率: <span class="${outOfSample.totalReturn >= 0 ? 'text-green-400' : 'text-red-400'}">${outOfSample.totalReturn.toFixed(2)}%</span></p>
                    <p class="text-xs text-gray-400">勝率: ${outOfSample.winRate.toFixed(1)}%</p>
                    <p class="text-xs text-gray-400">シャープレシオ: ${outOfSample.sharpeRatio.toFixed(2)}</p>
                    <p class="text-xs text-gray-400">最大DD: ${outOfSample.maxDrawdown.toFixed(1)}%</p>
                    <p class="text-xs text-gray-400">トレード数: ${outOfSample.trades}</p>
                </div>
            </div>
            <div class="text-xs text-gray-400 mt-2"><span class="font-semibold">最適パラメータ:</span> ${Object.entries(bestParams).map(([k, v]) => `${k}:${v}`).join(', ')}</div>
        </div>`;
        
        const container = document.getElementById('optimization-progress-container');
        if (container) {
             container.innerHTML = resultsHTML;
        } else {
             optimizationStatusEl.innerHTML = resultsHTML;
        }
    }
    
    // ★★★ START: 高速最適化のための新関数群を追加 ★★★
    async function runFastGeneticOptimization(preset) {
        const startTime = Date.now();
        const btcConfig = ASSET_CONFIGS.find(c => c.pair === 'BTC/USD');
        const timeframeKey = timeframeSelect.value;
        const config = timeframeConfigs[timeframeKey];
        
        updateOptimizationStatus('分析データを取得中...', 5);
        const data = await fetchData(btcConfig.fsym, btcConfig.tsym, config.endpoint, preset.dataPoints, config.aggregate);
        if (!data || data.length < 200) {
            createToast('最適化用のデータが不足しています。', 'error');
            optimizationStatusEl.textContent = 'データ不足で最適化を中止しました。';
            return;
        }

        const fullParamRanges = {
            rsiPeriod: [7, 9, 14, 21], emaShort: [5, 9, 12, 15], emaLong: [20, 26, 30, 40],
            signalThreshold: [2.5, 3.0, 3.5, 4.0], bbPeriod: [14, 20, 26], stochPeriod: [7, 14, 21]
        };
        const paramRanges = preset.paramKeys.reduce((acc, key) => { acc[key] = fullParamRanges[key]; return acc; }, {});

        let population = initializeRandomPopulation(preset.populationSize, paramRanges);
        let bestEver = { params: null, score: -Infinity, winRate: 0, trades: 0, expectedReturn: 0, riskRewardRatio: 0 };

        for (let gen = 0; gen < preset.generations; gen++) {
            const evaluated = [];
            for (let i = 0; i < population.length; i++) {
                const progress = ((gen * preset.populationSize + i + 1) / (preset.generations * preset.populationSize)) * 100;
                updateOptimizationStatus(`最適化中 (世代 ${gen + 1}/${preset.generations})`, progress);
                updateTimeEstimate(startTime, preset.generations * preset.populationSize, gen * preset.populationSize + i + 1);

                const result = evaluateFastStrategy(data, { ...baseAnalysisSettings.params, ...population[i] }, preset.sampleRate);
                if (result.score > bestEver.score) {
                    bestEver = { params: population[i], ...result };
                }
                evaluated.push({ params: population[i], ...result });
            }
            population = createNextGenerationFast(evaluated, paramRanges);
        }

        displayOptimizationResults(bestEver.params, bestEver, timeframeKey);
    }
    
    function evaluateFastStrategy(data, params, sampleRate) {
        const closes = data.map(d => d.close);
        const emaShort = calculateEMA(closes, params.emaShort);
        const emaLong = calculateEMA(closes, params.emaLong);
        const rsi = calculateRSI(closes, params.rsiPeriod);
        let trades = [];
        let openPosition = null;

        for (let i = params.emaLong; i < closes.length; i += sampleRate) {
            const emaShortIdx = i - (closes.length - emaShort.length);
            const emaLongIdx = i - (closes.length - emaLong.length);
            const rsiIdx = i - (closes.length - rsi.length);
            if (emaShortIdx < 0 || emaLongIdx < 0 || rsiIdx < 0) continue;
            
            let score = 0;
            if (emaShort[emaShortIdx] > emaLong[emaLongIdx]) score += 1.5;
            if (rsi[rsiIdx] < (params.rsiOversold || 30)) score += 1;
            if (rsi[rsiIdx] > (params.rsiOverbought || 70)) score -= 1;

            if (openPosition) {
                if ((openPosition.type === 'buy' && score < 0) || (openPosition.type === 'sell' && score > 0)) {
                    const profit = (closes[i] - openPosition.price) * (openPosition.type === 'buy' ? 1 : -1);
                    trades.push(profit / openPosition.price);
                    openPosition = null;
                }
            } else {
                if (score >= params.signalThreshold) openPosition = { type: 'buy', price: closes[i] };
                else if (score <= -params.signalThreshold) openPosition = { type: 'sell', price: closes[i] };
            }
        }

        if (trades.length < 5) return { score: -100, trades: 0, winRate: 0, expectedReturn: 0, riskRewardRatio: 0 };
        
        const wins = trades.filter(t => t > 0);
        const losses = trades.filter(t => t < 0);
        const winRate = wins.length / trades.length;
        const avgWin = wins.length > 0 ? wins.reduce((a, b) => a + b, 0) / wins.length : 0;
        const avgLoss = losses.length > 0 ? Math.abs(losses.reduce((a, b) => a + b, 0) / losses.length) : 0;
        const expectedReturn = (winRate * avgWin) - ((1 - winRate) * avgLoss);
        const riskRewardRatio = avgLoss > 0 ? avgWin / avgLoss : 0;
        const score = (expectedReturn * 1000) + (winRate * 50) + (riskRewardRatio * 10);
        
        return { score, trades: trades.length, winRate, expectedReturn: expectedReturn * 100, riskRewardRatio };
    }

    function initializeRandomPopulation(size, ranges) {
        return Array.from({ length: size }, () => {
            const individual = {};
            for (const [param, values] of Object.entries(ranges)) {
                individual[param] = values[Math.floor(Math.random() * values.length)];
            }
            return individual;
        });
    }

    function createNextGenerationFast(evaluated, ranges) {
        evaluated.sort((a, b) => b.score - a.score);
        const eliteCount = Math.max(2, Math.floor(evaluated.length * 0.4));
        const newPop = evaluated.slice(0, eliteCount).map(e => e.params);
        while (newPop.length < evaluated.length) {
            const parent1 = evaluated[Math.floor(Math.random() * eliteCount)].params;
            const parent2 = evaluated[Math.floor(Math.random() * eliteCount)].params;
            const child = {};
            for (const param in parent1) {
                child[param] = Math.random() < 0.5 ? parent1[param] : parent2[param];
                if (Math.random() < 0.1 && ranges[param]) {
                    child[param] = ranges[param][Math.floor(Math.random() * ranges[param].length)];
                }
            }
            newPop.push(child);
        }
        return newPop;
    }

    function displayQuickOptimizationResults(bestParams, performance) { // この関数は新しいdisplayOptimizationResultsに置き換えられます
        displayOptimizationResults(bestParams, performance, timeframeSelect.value);
    }
    
    function updateOptimizationStatus(message, progress = null) {
        const textEl = document.getElementById('optimization-progress-text');
        const barEl = document.getElementById('optimization-progress-bar');
        if (textEl) textEl.textContent = message;
        if (barEl && progress !== null) barEl.style.width = `${progress}%`;
    }

    function updateTimeEstimate(startTime, totalSteps, currentStep) {
        const timeEstimateEl = document.getElementById('optimization-time-estimate');
        if (!timeEstimateEl) return;

        const elapsedSeconds = (Date.now() - startTime) / 1000;
        if (currentStep > 1) {
            const timePerStep = elapsedSeconds / currentStep;
            const remainingSteps = totalSteps - currentStep;
            const remainingTime = Math.round(timePerStep * remainingSteps);
            const minutes = Math.floor(remainingTime / 60);
            const seconds = remainingTime % 60;
            timeEstimateEl.textContent = `残り時間: 約${minutes}分${seconds < 10 ? '0' : ''}${seconds}秒`;
        }
    }
    
    function displayOptimizationResults(bestParams, performance, timeframeKey) {
        let resultsHTML = `
            <div class="mt-4 p-4 bg-gray-900/50 rounded-lg">
                <h4 class="text-lg font-semibold text-green-400 mb-2">最適化完了！ (${timeframeConfigs[timeframeKey].label})</h4>
                <div class="grid grid-cols-2 gap-4 text-sm">
                    <div>
                        <p class="text-gray-400">最適化されたパラメータ:</p>
                        <ul class="text-white list-disc list-inside">${Object.entries(bestParams).map(([k, v]) => `<li>${k}: ${v}</li>`).join('')}</ul>
                    </div>
                    <div>
                        <p class="text-gray-400">推定パフォーマンス:</p>
                        <p class="text-white">予想勝率: ${(performance.winRate * 100).toFixed(1)}%</p>
                        <p class="text-white">期待リターン: ${performance.expectedReturn.toFixed(2)}%</p>
                        <p class="text-white">リスクリワード比: ${performance.riskRewardRatio.toFixed(2)}</p>
                    </div>
                </div>
                <div class="mt-4 flex gap-2">
                    <button id="apply-optimized-params-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded">この設定を適用</button>
                    <button id="optimize-other-btn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded">別の時間足を最適化</button>
                </div>
            </div>`;
        optimizationStatusEl.innerHTML = resultsHTML;

        document.getElementById('apply-optimized-params-btn').addEventListener('click', () => {
            baseAnalysisSettings.params = { ...baseAnalysisSettings.params, ...bestParams };
            localStorage.setItem('analysisSettings', JSON.stringify(baseAnalysisSettings));
            populateSettingsForm();
            createToast('最適化されたパラメータを適用しました。', 'success');
        });
        document.getElementById('optimize-other-btn').addEventListener('click', openTimeframeSelectorForOptimization);
    }
    
    function openTimeframeSelectorForOptimization() {
        const selected = prompt("最適化する時間足を選択:\n1: 1分, 2: 5分, 3: 15分, 4: 1時間, 5: 4時間, 6: 日足", "4");
        const map = {'1':'minute','2':'5minute','3':'15minute','4':'hour','5':'4hour','6':'day'};
        if (map[selected]) {
            timeframeSelect.value = map[selected];
            runOptimization();
        }
    }
    // ★★★ END: 高速最適化のための新関数群を追加 ★★★
    
    // --- Event Listeners ---
    timeframeSelect.addEventListener('change', (e) => updateAccuracyTooltip(e.target.value));
    runAnalysisBtn.addEventListener('click', () => {
        const existingProgress = document.getElementById('optimization-progress-container');
        if(existingProgress) existingProgress.remove();
        performAnalysis(true);
    });
    optimizeIndicatorsBtn.addEventListener('click', () => {
         const existingProgress = document.getElementById('optimization-progress-container');
        if(existingProgress) existingProgress.remove();
        runOptimization();
    });

    autoRefreshToggle.addEventListener('change', () => {
        if (autoRefreshToggle.checked) {
            runAnalysisBtn.disabled = true;
            performAnalysis(true);
            autoRefreshInterval = setInterval(() => performAnalysis(true), 300000);
            startCountdown();
        } else {
            runAnalysisBtn.disabled = false;
            clearInterval(autoRefreshInterval);
            clearInterval(countdownInterval);
            countdownTimerEl.textContent = '';
        }
    });

    function startCountdown() {
        let seconds = 300;
        const updateTimer = () => {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            countdownTimerEl.textContent = `次の更新まで: ${minutes}分${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}秒`;
        };
        updateTimer();
        countdownInterval = setInterval(() => {
            seconds--;
            updateTimer();
            if (seconds <= 0) seconds = 300;
        }, 1000);
    }

    Object.entries(tabs).forEach(([key, tab]) => {
        tab.addEventListener('click', () => {
            Object.values(panels).forEach(p => p.classList.add('hidden'));
            Object.values(tabs).forEach(t => t.classList.remove('active', 'border-indigo-500'));
            panels[key].classList.remove('hidden');
            tab.classList.add('active', 'border-indigo-500');
        });
    });
    
    resetHistoryBtn.addEventListener('click', () => {
        showConfirmation(
            '履歴のリセット',
            '本当にすべての履歴をリセットしますか？この操作は元に戻せません。',
            () => {
                createToast('全履歴をリセットしました。', 'info');
                signalHistory = []; analysisHistory = []; tradeHistory = []; openPositions = {};
                localStorage.clear();
                updateAccuracyUI();
                populateHistoryPanel();
                populateTradeHistoryPanel();
                updatePositionsUI();
            }
        );
    });

    document.body.addEventListener('click', (e) => {
        if (e.target.matches('.start-trade-btn')) {
            const { pair, signal, timeframe } = e.target.dataset;
            showTradeEntryModal(pair, signal, timeframe);
        }
        if (e.target.matches('.close-position-btn')) {
            const { pair, timeframe } = e.target.dataset;
            closePositionManually(pair, timeframe);
        }
        if (e.target.matches('.view-chart-btn')) {
             const { pair, takeprofit, stoploss, fiblevels, pivotlevels, impulse } = e.target.dataset;
             const assetConfig = ASSET_CONFIGS.find(c => c.pair === pair);
             if(assetConfig) {
                showChartModal(assetConfig, parseFloat(takeprofit), parseFloat(stoploss), JSON.parse(fiblevels), JSON.parse(pivotlevels), JSON.parse(impulse));
             }
        }
    });

    // --- Analysis Logic ---
    async function runRealAnalysis(assetConfig, timeframeKey, sentimentData) {
        const { fsym, tsym } = assetConfig;
        const config = timeframeConfigs[timeframeKey];
        if (!config) return null;

        const data = await fetchData(fsym, tsym, config.endpoint, config.limit, config.aggregate);
        if (!data || data.length < config.limit) {
             return null;
        }

        const analysisData = data;
        
        // Fetch previous day's data for pivot points
        const prevDayData = await fetchData(fsym, tsym, 'histoday', 2, 1);
        const yesterday = prevDayData ? prevDayData[0] : null;

        const fullResult = await performFullTechnicalAnalysis(assetConfig, timeframeKey, analysisData, false, null, yesterday, sentimentData);
        if (!fullResult) return null;

        const { signal, currentPrice, atr } = fullResult;
        
        const optimalLevels = findOptimalSLTP(analysisData, atr, assetConfig, timeframeKey);
        
        const lastAtr = atr[atr.length - 1] || currentPrice * 0.01;
        const stopLoss = signal === 'buy' ? currentPrice - (lastAtr * optimalLevels.bestSL) : currentPrice + (lastAtr * optimalLevels.bestSL);
        const takeProfit = signal === 'buy' ? currentPrice + (lastAtr * optimalLevels.bestTP) : currentPrice - (lastAtr * optimalLevels.bestTP);
        
        const predictiveRangeMultiplier = 0.5;
        const priceRangeUpper = currentPrice + (lastAtr * predictiveRangeMultiplier);
        const priceRangeLower = currentPrice - (lastAtr * predictiveRangeMultiplier);

        const modelAccuracy = getModelAccuracy(assetConfig.pair, timeframeKey);

        if(signal !== 'hold') {
            signalHistory.push({ 
                pair: assetConfig.pair, signal, entryPrice: currentPrice, 
                timestamp: Date.now(), status: 'pending', 
                timeframe: timeframeKey, 
                score: fullResult.score,
                marketRegime: fullResult.marketRegime,
                takeProfit, stopLoss 
            });
            saveSignalHistory();
        }
        
        return { ...fullResult, stopLoss, takeProfit, winRate: optimalLevels.bestWinRate, priceRangeUpper, priceRangeLower, modelAccuracy, assetConfig };
    }
    
    function findOptimalSLTP(historicalData, atr, assetConfig, timeframeKey) {
        // ★★★ START: 最適SL/TPを動的に計算するロジックに改良 ★★★
        if (!historicalData || historicalData.length < 50 || !atr || atr.length === 0) {
            // 十分なデータがない場合はデフォルト値を返す
            return { bestWinRate: 65.0, bestSL: 2.0, bestTP: 3.0 };
        }

        const config = timeframeConfigs[timeframeKey];
        if (!config) return { bestWinRate: 65.0, bestSL: 2.0, bestTP: 3.0 };

        // テストするSL/TPのATR倍率
        const slMultipliers = [1.5, 2.0, 2.5];
        const tpMultipliers = [2.0, 3.0, 4.0, 5.0];
        const lookForwardPeriod = 15; // 何本先までのローソク足で勝敗を判定するか

        let bestWinRate = 0;
        let bestSL = 2.0;
        let bestTP = 3.0;

        for (const slm of slMultipliers) {
            for (const tpm of tpMultipliers) {
                if (tpm <= slm) continue; // リスクリワード比が1以下の組み合わせは除外

                let wins = 0;
                let losses = 0;
                let trades = 0;

                // 過去データを使って簡易バックテストを実行
                for (let i = config.limit; i < historicalData.length - lookForwardPeriod; i++) {
                    const currentDataSlice = historicalData.slice(0, i + 1);
                    const signal = getBasicSignal(currentDataSlice, config); // 簡易シグナルでテスト

                    if (signal === 'hold') continue;

                    trades++;
                    const entryPrice = historicalData[i].close;
                    // atr配列のインデックスをhistoricalDataに合わせる
                    const atrIndex = i - (historicalData.length - atr.length);
                    if(atrIndex < 0) continue;
                    const currentAtr = atr[atrIndex] || entryPrice * 0.01;
                    
                    const stopLoss = signal === 'buy' ? entryPrice - (currentAtr * slm) : entryPrice + (currentAtr * slm);
                    const takeProfit = signal === 'buy' ? entryPrice + (currentAtr * tpm) : entryPrice - (currentAtr * tpm);
                    
                    let outcome = null;
                    // 未来の足を見てSL/TPにヒットするか確認
                    for (let j = 1; j <= lookForwardPeriod; j++) {
                        const futureBar = historicalData[i + j];
                        if (signal === 'buy') {
                            if (futureBar.low <= stopLoss) { outcome = 'loss'; break; }
                            if (futureBar.high >= takeProfit) { outcome = 'win'; break; }
                        } else { // sell
                            if (futureBar.high >= stopLoss) { outcome = 'loss'; break; }
                            if (futureBar.low <= takeProfit) { outcome = 'win'; break; }
                        }
                    }

                    if (outcome === 'win') wins++;
                    else if (outcome === 'loss') losses++;
                }

                if (trades > 5) { // 信頼できる結果を得るために最低5トレードは必要
                    const winRate = (wins / trades) * 100;
                    if (winRate > bestWinRate) {
                        bestWinRate = winRate;
                        bestSL = slm;
                        bestTP = tpm;
                    }
                }
            }
        }
        
        // 最適な設定が見つからなかった場合は安全なデフォルト値を返す
        if (bestWinRate === 0) {
            return { bestWinRate: 65.0, bestSL: 2.0, bestTP: 3.0 };
        }

        return { bestWinRate, bestSL, bestTP };
        // ★★★ END: 最適SL/TPを動的に計算するロジックに改良 ★★★
    }

    // New lightweight function to get a simple signal from data
    function getBasicSignal(data, config) {
        if (!data || data.length < config.params.emaLong) return 'hold';
        const closes = data.map(d => d.close);
        const ma1 = calculateEMA(closes, config.params.emaShort);
        const ma2 = calculateEMA(closes, config.params.emaLong);
        const macd = calculateMACD(calculateEMA(closes, 12), calculateEMA(closes, 26), 9);
        const last = (arr) => arr[arr.length - 1];
        const prev = (arr) => arr[arr.length - 2];

        if (prev(ma1) < prev(ma2) && last(ma1) > last(ma2)) return 'buy';
        if (prev(ma1) > prev(ma2) && last(ma1) < last(ma2)) return 'sell';
        if (last(closes) > last(ma2) && last(macd.macdLine) > last(macd.signalLine)) return 'buy';
        if (last(closes) < last(ma2) && last(macd.macdLine) < last(macd.signalLine)) return 'sell';
        return 'hold';
    }

    async function performFullTechnicalAnalysis(assetConfig, timeframeKey, data, isBacktest = false, tempConfig = null, yesterday = null, preFetchedSentiment = null) {
        const { fsym, tsym } = assetConfig;
        const config = tempConfig || timeframeConfigs[timeframeKey];
        const validatedData = ensureSufficientData(data, config.limit);

        const closes = validatedData.map(d => d.close);
        const highs = validatedData.map(d => d.high);
        const lows = validatedData.map(d => d.low);
        const volumes = validatedData.map(d => d.volume);
        const currentPrice = closes[closes.length - 1];

        if (!config) return null;

        const { params, weights: baseWeights, useEMA } = config;
        let score = 0;
        let keyReasons = [];

        const dynamicWeights = { ...baseWeights };
        
        // ★★★ START: 市場別最適化（為替 vs 仮想通貨 vs ゴールド） ★★★
        const assetType = assetConfig.pair.includes('XAUT') ? 'commodity' : assetConfig.type;
        
        // 為替市場の特性に合わせた調整
        if (assetType === 'forex') {
            // 為替はトレンド継続しやすいためトレンド系指標を重視
            dynamicWeights.ma *= 1.2;
            dynamicWeights.macd *= 1.2;
            dynamicWeights.ichimoku *= 1.3;
            
            // 為替ではRSI/ストキャスティクスのオシレーター系はやや軽視
            dynamicWeights.rsi *= 0.8;
            dynamicWeights.stoch *= 0.8;
            
            // ロンドン市場とNY市場の時間帯を考慮
            const hour = new Date().getUTCHours();
            const isActiveSession = (hour >= 7 && hour < 17); // ロンドン〜NY市場時間 (UTC)
            if (!isActiveSession) {
                score *= 0.7; // 非活動時間帯はシグナル強度を減衰
                keyReasons.push('<span class="text-yellow-400">⚠️ 注意:</span> 非主要市場時間帯のため信頼度低下');
            }
        } 
        // 仮想通貨市場の特性に合わせた調整
        else if (assetType === 'crypto') {
            // 仮想通貨はボラティリティが高いため、ATRとボリンジャーバンドを重視
            dynamicWeights.bb *= 1.2;
            dynamicWeights.atrVolatility = (dynamicWeights.atrVolatility || 1.2) * 1.3;
            
            // 仮想通貨は短期の値動きが大きいため、短期指標を重視
            dynamicWeights.maSlope *= 1.2;
        }
        // ゴールド（コモディティ）の特性に合わせた調整
        else if (assetType === 'commodity') {
            dynamicWeights.sentiment *= 1.2; // ゴールドではセンチメントを重視
            dynamicWeights.cci = (dynamicWeights.cci || 1.5) * 1.3; // ゴールドではCCIを重視
        }
        // ★★★ END: 市場別最適化 ★★★

        const last = (arr) => arr && arr.length > 0 ? arr[arr.length - 1] : 0;
        const prev = (arr) => arr && arr.length > 1 ? arr[arr.length - 2] : 0;

        // Higher Timeframe Analysis (MTA)
        const higherTimeframeSignals = [];
        // ★★★ START: MTA(上位足)のデータ取得を並列化 ★★★
        if (!isBacktest && config.mta && config.mta.length > 0) {
            const mtaPromises = config.mta.map(async (mta) => {
                const htfConfig = timeframeConfigs[mta.key];
                const htfData = await fetchData(fsym, tsym, htfConfig.endpoint, htfConfig.limit, htfConfig.aggregate);
                if (htfData) {
                    const htfSignal = getBasicSignal(htfData, htfConfig);
                    return { mta, htfSignal };
                }
                return null;
            });
            
            const mtaResults = (await Promise.all(mtaPromises)).filter(Boolean);

            mtaResults.forEach(({ mta, htfSignal }) => {
                if (htfSignal !== 'hold') {
                    score += (htfSignal === 'buy' ? 1 : -1) * dynamicWeights.mtaConfirmation * mta.weight;
                }
                higherTimeframeSignals.push({ key: mta.key, signal: htfSignal });
            });
        }
        // ★★★ END: MTA(上位足)のデータ取得を並列化 ★★★
        
        const adxResult = calculateADX(highs, lows, closes, params.adxPeriod);
        const lastAdx = last(adxResult.adx);
        const isTrending = lastAdx > params.adxThreshold;
        
        // Dynamically adjust weights based on market regime
        if (isTrending) {
            dynamicWeights.ma *= 1.2;
            dynamicWeights.macd *= 1.2;
            dynamicWeights.psar *= 1.3;
            dynamicWeights.rsi *= 0.8;
            dynamicWeights.stoch *= 0.8;
            dynamicWeights.bb *= 0.7;
        } else { // Ranging
            dynamicWeights.ma *= 0.8;
            dynamicWeights.macd *= 0.8;
            dynamicWeights.psar *= 0.7;
            dynamicWeights.rsi *= 1.2;
            dynamicWeights.stoch *= 1.2;
            dynamicWeights.bb *= 1.3;
        }
        
        const ma1 = useEMA ? safeCalculateIndicator(calculateEMA, closes, params.emaShort) : safeCalculateIndicator(calculateSMA, closes, params.smaShort);
        const ma2 = useEMA ? safeCalculateIndicator(calculateEMA, closes, params.emaLong) : safeCalculateIndicator(calculateSMA, closes, params.smaLong);
        const macd = safeCalculateIndicator(calculateMACD, calculateEMA(closes, params.emaShort), calculateEMA(closes, params.emaLong), params.macdSignal) || { macdLine: [], signalLine: [], histogram: [] };
        const rsi = safeCalculateIndicator(calculateRSI, closes, params.rsiPeriod);
        const stoch = safeCalculateIndicator(calculateStochastic, closes, highs, lows, params.stochPeriod, 3) || { k: [], d: [] };
        const bb = safeCalculateIndicator(calculateBollingerBands, closes, params.bbPeriod, params.bbStdDev) || { upper: [], lower: [], middle: [] };
        const ichimoku = safeCalculateIndicator(calculateIchimoku, highs, lows, closes, params) || { tenkan: [], kijun: [], senkouA: [], senkouB: [] };
        const vwap = safeCalculateIndicator(calculateVWAP, closes, highs, lows, volumes);
        const psar = safeCalculateIndicator(calculateParabolicSAR, highs, lows, params);
        const atr = safeCalculateIndicator(calculateATR, highs,lows,closes,params.atrPeriod);
        // New Indicators
        const bbw = safeCalculateIndicator(calculateBollingerBandWidth, bb);
        const obv = safeCalculateIndicator(calculateOBV, closes, volumes);
        const elderImpulse = safeCalculateIndicator(calculateElderImpulse, ma1, macd.histogram);
        const cci = safeCalculateIndicator(calculateCCI, highs, lows, closes, params.cciPeriod); // ★ CCIを計算

        // Squeeze Indicator Calculation
        const bbwSlice = bbw.slice(-(params.bbwSqueezeLookback || 50));
        const minBbw = bbwSlice.length > 0 ? Math.min(...bbwSlice) : 0;
        const isSqueeze = last(bbw) <= minBbw * (1 + (params.bbwSqueezeThreshold || 0.1));
        const prevSqueeze = bbw.length > 1 && bbw[bbw.length - 2] <= minBbw * (1 + (params.bbwSqueezeThreshold || 0.1));


        if (prev(ma1) < prev(ma2) && last(ma1) > last(ma2)) { score += dynamicWeights.ma; keyReasons.push(`<span class="text-green-400">▲ 買い:</span> ${useEMA ? 'EMA' : 'SMA'}ゴールデンクロス`); }
        else if (prev(ma1) > prev(ma2) && last(ma1) < last(ma2)) { score -= dynamicWeights.ma; keyReasons.push(`<span class="text-red-400">▼ 売り:</span> ${useEMA ? 'EMA' : 'SMA'}デッドクロス`); }

        const slope = calculateSlope(ma2, params.slopePeriod);
        const slopeThreshold = last(closes) * 0.0005;
        if(slope > slopeThreshold) { score += dynamicWeights.maSlope; keyReasons.push(`<span class="text-green-400">▲ 買い:</span> トレンド強度 (強い上昇)`);}
        else if(slope < -slopeThreshold) { score -= dynamicWeights.maSlope; keyReasons.push(`<span class="text-red-400">▼ 売り:</span> トレンド強度 (強い下降)`);}


        if (prev(macd.macdLine) < prev(macd.signalLine) && last(macd.macdLine) > last(macd.signalLine)) { score += dynamicWeights.macd; keyReasons.push('<span class="text-green-400">▲ 買い:</span> MACDゴールデンクロス'); }
        else if (prev(macd.macdLine) > prev(macd.signalLine) && last(macd.macdLine) < last(macd.signalLine)) { score -= dynamicWeights.macd; keyReasons.push('<span class="text-red-400">▼ 売り:</span> MACDデッドクロス'); }
        
        if (last(rsi) < params.rsiOversold) { score += dynamicWeights.rsi; keyReasons.push(`<span class="text-green-400">▲ 買い:</span> RSI売られすぎ (${last(rsi).toFixed(1)})`); }
        else if (last(rsi) > params.rsiOverbought) { score -= dynamicWeights.rsi; keyReasons.push(`<span class="text-red-400">▼ 売り:</span> RSI買われすぎ (${last(rsi).toFixed(1)})`); }

        if (last(stoch.k) < params.stochOversold) { score += dynamicWeights.stoch; keyReasons.push(`<span class="text-green-400">▲ 買い:</span> ストキャスティクス売られすぎ (${last(stoch.k).toFixed(1)})`); }
        else if (last(stoch.k) > params.stochOverbought) { score -= dynamicWeights.stoch; keyReasons.push(`<span class="text-red-400">▼ 売り:</span> ストキャスティクス買われすぎ (${last(stoch.k).toFixed(1)})`); }
        
        if (last(closes) < last(bb.lower)) { score += dynamicWeights.bb; keyReasons.push('<span class="text-green-400">▲ 買い:</span> ボリンジャーバンド下限タッチ'); }
        else if (last(closes) > last(bb.upper)) { score -= dynamicWeights.bb; keyReasons.push('<span class="text-red-400">▼ 売り:</span> ボリンジャーバンド上限タッチ'); }

        // ★★★ START: CCI分析ロジック追加 ★★★
        if (last(cci) > 100) { score -= (dynamicWeights.cci || 1.5); keyReasons.push(`<span class="text-red-400">▼ 売り:</span> CCI買われすぎ (${last(cci).toFixed(1)})`); }
        else if (last(cci) < -100) { score += (dynamicWeights.cci || 1.5); keyReasons.push(`<span class="text-green-400">▲ 買い:</span> CCI売られすぎ (${last(cci).toFixed(1)})`); }
        // ★★★ END: CCI分析ロジック追加 ★★★

        if (currentPrice > last(ichimoku.senkouA) && currentPrice > last(ichimoku.senkouB) && last(ichimoku.tenkan) > last(ichimoku.kijun)) { score += dynamicWeights.ichimoku; keyReasons.push('<span class="text-green-400">▲ 買い:</span> 一目均衡表・三役好転'); }
        else if (currentPrice < last(ichimoku.senkouA) && currentPrice < last(ichimoku.senkouB) && last(ichimoku.tenkan) < last(ichimoku.kijun)) { score -= dynamicWeights.ichimoku; keyReasons.push('<span class="text-red-400">▼ 売り:</span> 一目均衡表・三役逆転'); }

        // VWAP分析（デイトレード向けに強化）
        if (vwap > 0) {
            const vwapDistance = ((currentPrice - vwap) / vwap) * 100;
            // 基本的なVWAPとの位置関係
            if (currentPrice > vwap) {
                score += dynamicWeights.vwap;
                keyReasons.push(`<span class="text-green-400">▲ 買い:</span> VWAPより上 (${vwapDistance.toFixed(2)}%)`);
            } else {
                score -= dynamicWeights.vwap;
                keyReasons.push(`<span class="text-red-400">▼ 売り:</span> VWAPより下 (${vwapDistance.toFixed(2)}%)`);
            }
            // 乖離が大きい場合は追加スコア
            if (vwapDistance > 1.5) {
                score += dynamicWeights.vwap * 0.5;
                keyReasons.push(`<span class="text-green-400">▲ 買い:</span> VWAPより大幅乖離`);
            } else if (vwapDistance < -1.5) {
                score -= dynamicWeights.vwap * 0.5;
                keyReasons.push(`<span class="text-red-400">▼ 売り:</span> VWAPより大幅乖離`);
            }
        }

        // オーダーブロック検出（デイトレで有効）
        const orderBlocks = detectOrderBlocks(data);
        if (orderBlocks.bullish && currentPrice >= orderBlocks.bullish.low && currentPrice <= orderBlocks.bullish.high) {
            score += dynamicWeights.chartPatterns * 0.8;
            keyReasons.push('<span class="text-green-400">▲ 買い:</span> 強気のオーダーブロックで反発期待');
        }
        if (orderBlocks.bearish && currentPrice <= orderBlocks.bearish.high && currentPrice >= orderBlocks.bearish.low) {
            score -= dynamicWeights.chartPatterns * 0.8;
            keyReasons.push('<span class="text-red-400">▼ 売り:</span> 弱気のオーダーブロックで反落期待');
        }

        if (last(closes) > last(psar)) { score += dynamicWeights.psar; keyReasons.push('<span class="text-green-400">▲ 買い:</span> パラボリックSAR転換'); }
        else if (last(closes) < last(psar)) { score -= dynamicWeights.psar; keyReasons.push('<span class="text-red-400">▼ 売り:</span> パラボリックSAR転換'); }

        const patternResult = detectChartPatterns(highs, lows, closes);
        if (patternResult.signal !== 'none') {
            score += (patternResult.signal === 'buy' ? 1 : -1) * dynamicWeights.chartPatterns;
            keyReasons.push(`<span class="${patternResult.signal === 'buy' ? 'text-green-400' : 'text-red-400'}">${patternResult.signal === 'buy' ? '▲ 買い:' : '▼ 売り:'}</span> チャートパターン (${patternResult.pattern})`);
        }
        
        const rsiDivergence = detectDivergence(closes, rsi, params.divergenceLookback, params.divergenceOffset, 'RSI');
        if (rsiDivergence.signal !== 'none') { score += (rsiDivergence.signal === 'buy' ? 1 : -1) * dynamicWeights.divergence; keyReasons.push(`<span class="text-cyan-400">🔮 転換予兆:</span> ${rsiDivergence.type}`); }
        
        const stochDivergence = detectDivergence(closes, stoch.k, params.divergenceLookback, params.divergenceOffset, 'STOCH');
        if (stochDivergence.signal !== 'none') { score += (stochDivergence.signal === 'buy' ? 1 : -1) * dynamicWeights.divergence; keyReasons.push(`<span class="text-cyan-400">🔮 転換予兆:</span> ${stochDivergence.type}`); }

        // Fibonacci Retracement Analysis
        const recentSwingHigh = Math.max(...highs.slice(-50));
        const recentSwingLow = Math.min(...lows.slice(-50));
        const fibLevels = calculateFibonacciRetracement(recentSwingHigh, recentSwingLow);
        if (currentPrice < fibLevels.level618 && currentPrice > fibLevels.level786) {
             score += dynamicWeights.fibonacci * 0.8;
             keyReasons.push(`<span class="text-green-400">▲ 買い:</span> フィボナッチ 61.8%押し目`);
        } else if (currentPrice > fibLevels.level382 && currentPrice < fibLevels.level236) {
             score -= dynamicWeights.fibonacci * 0.8;
             keyReasons.push(`<span class="text-red-400">▼ 売り:</span> フィボナッチ 61.8%戻り`);
        }

        // Pivot Point Analysis
        const pivotLevels = yesterday ? calculatePivotPoints(yesterday.high, yesterday.low, yesterday.close) : null;
        if (pivotLevels) {
            if (currentPrice > pivotLevels.r1) { score += dynamicWeights.pivot; keyReasons.push(`<span class="text-green-400">▲ 買い:</span> ピボットR1を上抜け`);}
            else if (currentPrice < pivotLevels.s1) { score -= dynamicWeights.pivot; keyReasons.push(`<span class="text-red-400">▼ 売り:</span> ピボットS1を下抜け`);}
            else if (currentPrice > pivotLevels.pivot) { score += dynamicWeights.pivot * 0.5; keyReasons.push(`<span class="text-green-400">▲ 買い:</span> ピボットポイントより上`);}
            else { score -= dynamicWeights.pivot * 0.5; keyReasons.push(`<span class="text-red-400">▼ 売り:</span> ピボットポイントより下`);}
        }


        // OBV Divergence
        const obvDivergence = detectDivergence(closes, obv, params.divergenceLookback, params.divergenceOffset, 'OBV');
        if (obvDivergence.signal !== 'none') { score += (obvDivergence.signal === 'buy' ? 1 : -1) * dynamicWeights.obvDivergence; keyReasons.push(`<span class="text-cyan-400">🔮 出来高の転換予兆:</span> ${obvDivergence.type}`); }
        
        // Determine a preliminary signal before Squeeze logic
        let signal = 'hold';
        if (score >= params.signalThreshold) signal = 'buy';
        if (score <= -params.signalThreshold) signal = 'sell';

        // Squeeze Logic
        if (prevSqueeze && !isSqueeze && signal !== 'hold') {
            score += (signal === 'buy' ? 1 : -1) * dynamicWeights.squeeze;
            keyReasons.push('<span class="font-bold text-orange-400">⚡️ スクイーズ・ブレイクアウト！</span>');
        }

        if (!isBacktest && preFetchedSentiment) {
            let sentimentScore = 0; let sentimentReason = '';
            if (preFetchedSentiment.length > 0) {
                let totalSentiment = 0;
                const recentArticles = preFetchedSentiment.slice(0, 5);
                recentArticles.forEach(article => {
                    if (article.sentiment === 'POSITIVE') totalSentiment += 1;
                    else if (article.sentiment === 'NEGATIVE') totalSentiment -= 1;
                });
                const avgSentiment = recentArticles.length > 0 ? totalSentiment / recentArticles.length : 0;
                if (avgSentiment > 0.4) { sentimentScore = 1; sentimentReason = '📊 市場心理: 強気'; } 
                else if (avgSentiment < -0.4) { sentimentScore = -1; sentimentReason = '📊 市場心理: 弱気'; } 
                else { sentimentReason = '📊 市場心理: 中立'; }
            } else { sentimentReason = '📊 市場心理: データなし'; }
            if (sentimentScore !== 0) {
                score += sentimentScore * dynamicWeights.sentiment;
                keyReasons.push(`<span class="${sentimentScore > 0 ? 'text-green-400' : 'text-red-400'}">${sentimentReason}</span>`);
            } else { keyReasons.push(`<span class="text-yellow-400">${sentimentReason}</span>`); }
        }
        
        const avgVolume = volumes.slice(-21, -1).reduce((a, b) => a + b, 0) / 20;
        if (last(volumes) > avgVolume * params.volumeSpikeMultiplier) {
            score += (score > 0 ? 1 : -1) * dynamicWeights.volumeConfirmation;
            keyReasons.push('<span class="text-blue-400">ⓘ 注目:</span> 出来高急増');
        }

        // ★★★ START: ATRボラティリティ分析ロジック追加 ★★★
        const atrSma = calculateSMA(atr, params.atrPeriod);
        if (atr.length > params.atrPeriod && last(atr) > last(atrSma) * params.atrVolatilityThreshold) {
            // ボラティリティが急拡大した場合、現在のシグナルの方向にスコアを加算してトレンドを後押し
            if (score !== 0) {
                 score += (score > 0 ? 1 : -1) * (dynamicWeights.atrVolatility || 1.2);
                 keyReasons.push('<span class="text-blue-400">ⓘ 注目:</span> ボラティリティ急拡大');
            }
        }
        // ★★★ END: ATRボラティリティ分析ロジック追加 ★★★

        // Elder Impulse System Confirmation
        const lastImpulse = last(elderImpulse);
        if (signal === 'buy' && lastImpulse === 'green') {
            score += dynamicWeights.elderImpulse;
            keyReasons.push(`<span class="text-teal-400">⚡️ エルダーインパルス: 買いの勢い一致</span>`);
        } else if (signal === 'sell' && lastImpulse === 'red') {
            score -= dynamicWeights.elderImpulse;
            keyReasons.push(`<span class="text-teal-400">⚡️ エルダーインパルス: 売りの勢い一致</span>`);
        } else if (signal !== 'hold' && lastImpulse !== 'blue') {
            score *= 0.8; // Penalize if signal and impulse conflict
            keyReasons.push(`<span class="text-yellow-400">⚠️ エルダーインパルス: シグナルと勢いが不一致</span>`);
        }
        
        if (higherTimeframeSignals.length > 0) {
            const allBuy = higherTimeframeSignals.every(s => s.signal === 'buy');
            const allSell = higherTimeframeSignals.every(s => s.signal === 'sell');
            if (signal === 'buy' && allBuy) {
                score += dynamicWeights.mtaAlignment;
                keyReasons.push(`<span class="text-yellow-500 font-bold">⭐ 上位足完全一致 (買い)</span>`);
            } else if (signal === 'sell' && allSell) {
                score -= dynamicWeights.mtaAlignment;
                keyReasons.push(`<span class="text-yellow-500 font-bold">⭐ 上位足完全一致 (売り)</span>`);
            }
        }

        let trendReason = `<span class="text-purple-400">市場環境: ${isTrending ? 'トレンド' : 'レンジ'} (ADX: ${lastAdx.toFixed(1)})</span>`;
        if (higherTimeframeSignals.length > 0) {
             trendReason += `<br><span class="text-purple-400">上位足: ${higherTimeframeSignals.map(s => {
                 const color = s.signal === 'buy' ? 'text-green-400' : s.signal === 'sell' ? 'text-red-400' : 'text-gray-400';
                 return `<span class="${color}">${timeframeConfigs[s.key].label}:${s.signal}</span>`;
             }).join(' ')}</span>`;
        }
        keyReasons.unshift(trendReason);

        if (keyReasons.length <= 1) keyReasons.push('<span class="text-yellow-400">― 中立:</span> 明確なシグナルなし');
        
        if (score >= params.signalThreshold) signal = 'buy';
        else if (score <= -params.signalThreshold) signal = 'sell';
        else signal = 'hold';

        let leverage = 1; const absScore = Math.abs(score);
        if (signal !== 'hold') {
            if (absScore >= 8.5) leverage = 20; else if (absScore >= 6.5) leverage = 10; else if (absScore >= 4.5) leverage = 5;
        }

        const optimalLevels = findOptimalSLTP(data, atr, assetConfig, timeframeKey);
        return { signal, score, keyReasons, leverage, currentPrice, marketRegime: isTrending ? 'trend' : 'range', atr, winRate: optimalLevels.bestWinRate, fibLevels, pivotLevels, elderImpulse };
    }

    // --- Chart Pattern Detection ---
    function findPeaksAndTroughs(data, window = 5) {
        const peaks = [], troughs = [];
        if (data.length < window) return { peaks, troughs };
        const w = Math.floor(window / 2);
        for (let i = w; i < data.length - w; i++) {
            const slice = data.slice(i - w, i + w + 1);
            const middleValue = data[i];
            if (middleValue === Math.max(...slice)) peaks.push({ index: i, value: middleValue });
            if (middleValue === Math.min(...slice)) troughs.push({ index: i, value: middleValue });
        }
        return { peaks, troughs };
    }

    function detectChartPatterns(highs, lows, closes) {
        const { peaks } = findPeaksAndTroughs(highs, 10);
        const { troughs } = findPeaksAndTroughs(lows, 10);
        const currentPrice = closes[closes.length - 1];
        const tolerance = 0.015;

        if (peaks.length >= 2) {
            const [p1, p2] = peaks.slice(-2);
            if (p2.index > closes.length - 20 && Math.abs(p1.value - p2.value) / p1.value < tolerance) {
                const interveningTrough = troughs.find(t => t.index > p1.index && t.index < p2.index);
                if (interveningTrough && currentPrice < interveningTrough.value) return { signal: 'sell', pattern: 'ダブルトップ' };
            }
        }
        if (troughs.length >= 2) {
            const [t1, t2] = troughs.slice(-2);
            if (t2.index > closes.length - 20 && Math.abs(t1.value - t2.value) / t1.value < tolerance) {
                const interveningPeak = peaks.find(p => p.index > t1.index && p.index < t2.index);
                if (interveningPeak && currentPrice > interveningPeak.value) return { signal: 'buy', pattern: 'ダブルボトム' };
            }
        }
        return { signal: 'none', pattern: null };
    }

    function detectDivergence(prices, oscillator, lookback = 40, offset = 5, name = 'OSC') {
        if (prices.length < lookback + offset || oscillator.length < lookback + offset) return { signal: 'none' };
        
        const alignedOscillator = oscillator.length < prices.length ? Array(prices.length - oscillator.length).fill(null).concat(oscillator) : oscillator;

        const recentPrices = prices.slice(-lookback);
        const prevPrices = prices.slice(-lookback - offset, -offset);

        const recentLowPrice = Math.min(...recentPrices);
        const recentLowPriceIdx = prices.lastIndexOf(recentLowPrice);
        const recentLowOsc = alignedOscillator[recentLowPriceIdx];

        const prevLowPrice = Math.min(...prevPrices);
        const prevLowPriceIdx = prices.lastIndexOf(prevLowPrice, -offset);
        const prevLowOsc = alignedOscillator[prevLowPriceIdx];

        if (recentLowPrice < prevLowPrice && recentLowOsc > prevLowOsc) {
            return { signal: 'buy', type: `${name} 強気のダイバージェンス` };
        }

        const recentHighPrice = Math.max(...recentPrices);
        const recentHighPriceIdx = prices.lastIndexOf(recentHighPrice);
        const recentHighOsc = alignedOscillator[recentHighPriceIdx];

        const prevHighPrice = Math.max(...prevPrices);
        const prevHighPriceIdx = prices.lastIndexOf(prevHighPrice, -offset);
        const prevHighOsc = alignedOscillator[prevHighPriceIdx];

        if (recentHighPrice > prevHighPrice && recentHighOsc < prevHighOsc) {
            return { signal: 'sell', type: `${name} 弱気のダイバージェンス` };
        }
        
        return { signal: 'none', type: null };
    }

    // --- Accuracy & Trade History ---
    function saveSignalHistory() { localStorage.setItem('signalHistory', JSON.stringify(signalHistory)); }
    async function verifySignals() {
        let changed = false;
        const pendingSignals = signalHistory.filter(s => s.status === 'pending');
        if (pendingSignals.length === 0) return;

        for (const signal of pendingSignals) {
            const assetConfig = ASSET_CONFIGS.find(c => c.pair === signal.pair);
            if (!assetConfig) continue;

            const config = timeframeConfigs[signal.timeframe];
            if (!config) continue;

            const now = Date.now();
            const timeDiff = now - signal.timestamp;

            const timeoutHours = parseInt(document.getElementById('timeout-select')?.value || '4');
            const timeout = timeoutHours * 60 * 60 * 1000;
            if (timeDiff > timeout) {
                signal.status = 'timeout';
                changed = true;
                continue;
            }
            
            const barDuration = (config.endpoint === 'histominute' ? config.aggregate * 60000 : (config.endpoint === 'histohour' ? config.aggregate * 3600000 : 86400000));
            if (timeDiff < barDuration * 2) continue;
            
            const barsToFetch = Math.min(config.verificationPeriod, Math.floor(timeDiff / barDuration));
            if (barsToFetch < 1) continue;
            
            const verificationData = await fetchData(assetConfig.fsym, assetConfig.tsym, config.endpoint, barsToFetch, config.aggregate);
            if (!verificationData || verificationData.length === 0) continue;

            // ★★★ START: 決済ロジックをより現実に近い形に修正 ★★★
            let outcome = 'pending';
            let exitPrice = signal.entryPrice;
            const entryTimestamp = signal.timestamp / 1000;

            // Fetch data from signal time up to verification period
            const dataSinceSignal = await fetchData(
                assetConfig.fsym, assetConfig.tsym, 
                config.endpoint, 
                config.verificationPeriod + 1, // +1 for safety margin
                config.aggregate
            );

            if (dataSinceSignal) {
                const relevantBars = dataSinceSignal.filter(d => d.time > entryTimestamp);
                for (const bar of relevantBars) {
                    if (signal.signal === 'buy') {
                        if (bar.low <= signal.stopLoss) { outcome = 'failed'; exitPrice = signal.stopLoss; break; }
                        if (bar.high >= signal.takeProfit) { outcome = 'success'; exitPrice = signal.takeProfit; break; }
                    } else { // sell
                        if (bar.high >= signal.stopLoss) { outcome = 'failed'; exitPrice = signal.stopLoss; break; }
                        if (bar.low <= signal.takeProfit) { outcome = 'success'; exitPrice = signal.takeProfit; break; }
                    }
                }
                 // If no SL/TP hit within the period, close at the last known price
                if (outcome === 'pending' && timeDiff > barDuration * config.verificationPeriod) {
                    const finalPrice = relevantBars.length > 0 ? relevantBars[relevantBars.length - 1].close : signal.entryPrice;
                    if ((signal.signal === 'buy' && finalPrice > signal.entryPrice) || (signal.signal === 'sell' && finalPrice < signal.entryPrice)) {
                        outcome = 'success';
                    } else {
                        outcome = 'failed';
                    }
                    exitPrice = finalPrice;
                }
            }

            if (outcome !== 'pending') {
                signal.status = outcome;
                signal.exitPrice = exitPrice; // Store exit price for P/L calculation
                changed = true;
            }
            // ★★★ END: 決済ロジックをより現実に近い形に修正 ★★★
            await delay(500);
        }

        if (changed) {
            saveSignalHistory();
            updateAccuracyUI();
        }
    }

    function updateAccuracyTooltip(timeframeKey) {
        const config = timeframeConfigs[timeframeKey];
        if (!config) return;
        
        let verificationText = '';
        const periodInBars = config.verificationPeriod;
        let unit = '';
        if (config.endpoint === 'histominute') unit = '分';
        else if (config.endpoint === 'histohour') unit = '時間';
        else unit = '日';

        const totalMinutes = periodInBars * (config.aggregate || 1) * (unit === '分' ? 1 : (unit === '時間' ? 60 : 1440));
        
        if (totalMinutes < 60) verificationText = `${totalMinutes}分後`;
        else if (totalMinutes < 1440) verificationText = `${totalMinutes / 60}時間後`;
        else verificationText = `${totalMinutes / 1440}日後`;

        accuracyTooltipText.textContent = `「${config.label}」のシグナルが、最大${verificationText}の間に損切りより先に利確に到達したかを判定します。`;
    }

    function updateAccuracyUI() {
        const verifiedSignals = signalHistory.filter(s => s.status !== 'pending');
        const successful = verifiedSignals.filter(s => s.status === 'success').length;
        const failed = verifiedSignals.filter(s => s.status === 'failed' || s.status === 'timeout').length;
        const total = verifiedSignals.length;
        totalVerifiedEl.textContent = total;
        successfulSignalsEl.textContent = successful;
        failedSignalsEl.textContent = failed;
        accuracyRateEl.textContent = total > 0 ? `${((successful / total) * 100).toFixed(1)}%` : '---';
        
        // --- Call new detailed stats functions ---
        updateAdvancedStats(verifiedSignals);
        updateConditionWiseStats(document.querySelector('.condition-filter-btn.active').dataset.filter, verifiedSignals);
        renderWinRateTrendChart(verifiedSignals);
    }

    // --- New Detailed Stats Functions ---
    function updateAdvancedStats(verifiedSignals) {
        if (verifiedSignals.length < 5) {
            advancedStatsContainer.innerHTML = '<p class="text-xs text-gray-500 text-center">詳細統計を表示するには、さらに検証済みシグナルが必要です。</p>';
            return;
        }

        let grossProfit = 0;
        let grossLoss = 0;

        verifiedSignals.forEach(s => {
            if (s.exitPrice) {
                const pnl = s.signal === 'buy' ? s.exitPrice - s.entryPrice : s.entryPrice - s.exitPrice;
                if (s.status === 'success') grossProfit += pnl / s.entryPrice;
                else grossLoss += Math.abs(pnl / s.entryPrice);
            } else { // Fallback for older data without exitPrice
                 if (s.status === 'success') grossProfit += 0.015; // Assume 1.5% profit
                 else grossLoss += 0.01; // Assume 1% loss
            }
        });

        const profitFactor = grossLoss > 0 ? (grossProfit / grossLoss).toFixed(2) : '∞';
        const totalNet = (grossProfit - grossLoss) * 100;

        advancedStatsContainer.innerHTML = `
            <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm">
                <div class="flex justify-between items-center bg-gray-700/50 p-2 rounded-lg"><span class="font-semibold text-gray-300">総損益率:</span><span class="font-bold ${totalNet >= 0 ? 'text-green-400' : 'text-red-400'}">${totalNet.toFixed(2)}%</span></div>
                <div class="flex justify-between items-center bg-gray-700/50 p-2 rounded-lg"><span class="font-semibold text-gray-300">PF:</span><span class="font-bold text-white">${profitFactor}</span></div>
            </div>
        `;
    }

    function updateConditionWiseStats(filter, allSignals) {
        const signals = allSignals || signalHistory.filter(s => s.status !== 'pending');
        if (signals.length === 0) {
            conditionWiseStatsEl.innerHTML = '<p class="text-xs text-gray-500 text-center">データがありません。</p>';
            return;
        }

        let grouped = {};
        if (filter === 'timeframe') {
            grouped = signals.reduce((acc, s) => {
                const key = timeframeConfigs[s.timeframe]?.label || s.timeframe;
                if (!acc[key]) acc[key] = { success: 0, total: 0 };
                acc[key].total++;
                if (s.status === 'success') acc[key].success++;
                return acc;
            }, {});
        } else if (filter === 'score') {
             grouped = signals.reduce((acc, s) => {
                const score = s.score || 0;
                const key = score > 8 ? '8+' : score > 6 ? '6-8' : score > 4 ? '4-6' : '<4';
                if (!acc[key]) acc[key] = { success: 0, total: 0 };
                acc[key].total++;
                if (s.status === 'success') acc[key].success++;
                return acc;
            }, {});
        } else if (filter === 'session') {
            grouped = signals.reduce((acc, s) => {
                const hour = new Date(s.timestamp).getUTCHours();
                const key = (hour >= 23 || hour < 8) ? '東京' : (hour >= 8 && hour < 16) ? 'ロンドン' : 'NY';
                if (!acc[key]) acc[key] = { success: 0, total: 0 };
                acc[key].total++;
                if (s.status === 'success') acc[key].success++;
                return acc;
            }, {});
        } else if (filter === 'regime') {
             grouped = signals.reduce((acc, s) => {
                const key = s.marketRegime === 'trend' ? 'トレンド相場' : 'レンジ相場';
                if (!acc[key]) acc[key] = { success: 0, total: 0 };
                acc[key].total++;
                if (s.status === 'success') acc[key].success++;
                return acc;
            }, {});
        }

        let html = '<div class="space-y-2">';
        Object.entries(grouped).sort((a,b)=>b[1].total - a[1].total).forEach(([key, value]) => {
            const winRate = value.total > 0 ? (value.success / value.total) * 100 : 0;
            const color = winRate > 65 ? 'bg-green-500' : winRate > 50 ? 'bg-yellow-500' : 'bg-red-500';
            html += `
                <div class="text-xs">
                    <div class="flex justify-between mb-1">
                        <span>${key} (${value.total}件)</span>
                        <span>${winRate.toFixed(1)}%</span>
                    </div>
                    <div class="progress-bar-bg">
                        <div class="progress-bar-fill ${color}" style="width: ${winRate}%"></div>
                    </div>
                </div>
            `;
        });
        html += '</div>';
        conditionWiseStatsEl.innerHTML = html;
    }

    function renderWinRateTrendChart(verifiedSignals) {
        if (winRateChartInstance) {
            winRateChartInstance.destroy();
        }
        if (verifiedSignals.length < 10) return;

        const last50Signals = verifiedSignals.slice(-50);
        let successCount = 0;
        const trendData = last50Signals.map((s, index) => {
            if (s.status === 'success') successCount++;
            return {
                x: index + 1,
                y: (successCount / (index + 1)) * 100
            };
        });

        const ctx = winRateTrendChartCanvas.getContext('2d');
        winRateChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: '勝率トレンド',
                    data: trendData,
                    borderColor: 'rgb(99, 102, 241)',
                    backgroundColor: 'rgba(99, 102, 241, 0.2)',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.4,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { display: false },
                    y: { 
                        grid: { color: 'rgba(255,255,255,0.1)' },
                        ticks: { callback: value => value + '%' }
                    }
                },
                plugins: { legend: { display: false } }
            }
        });
    }


    // --- Trading Logic ---
    async function showTradeEntryModal(pair, signal, timeframe) {
        const assetConfig = ASSET_CONFIGS.find(c => c.pair === pair);
        if (!assetConfig) return;

        const currencySymbol = assetConfig.tsym === 'JPY' ? '¥' : '$';
        const locale = assetConfig.tsym === 'JPY' ? 'ja-JP' : 'en-US';

        const priceData = await fetchCurrentPrice([assetConfig]);
        if (!priceData || !priceData[assetConfig.fsym] || !priceData[assetConfig.fsym][assetConfig.tsym]) {
            createToast(`${pair}の価格取得に失敗`, 'error');
            return;
        }
        const price = priceData[assetConfig.fsym][assetConfig.tsym].PRICE;
        tradeEntryTitle.textContent = `${pair} ${signal.toUpperCase()} @ ${currencySymbol}${price.toLocaleString(locale)}`;
        tradeAmountLabel.textContent = `取引金額 (${assetConfig.tsym})`;
        tradeAmountInput.value = '';
        tradeEntryModal.classList.remove('hidden');
        
        confirmTradeBtn.onclick = () => {
            const amountInQuote = parseFloat(tradeAmountInput.value);
            if (amountInQuote > 0) {
                const quantity = amountInQuote / price;
                startTrade(pair, signal, price, quantity, timeframe);
                tradeEntryModal.classList.add('hidden');
            } else {
                createToast('有効な金額を入力してください', 'error');
            }
        };
    }
    cancelTradeBtn.onclick = () => tradeEntryModal.classList.add('hidden');

    function startTrade(pair, signal, entryPrice, amount, timeframe) {
        if (!openPositions[timeframe]) {
            openPositions[timeframe] = {};
        }
        if (openPositions[timeframe][pair]) { 
            createToast(`${pair} (${timeframe}) は既に保有中`, 'error'); 
            return; 
        }

        const analysisResult = analysisHistory[0].results.find(r => r.assetConfig.pair === pair);
        if (!analysisResult) {
            createToast('ポジション開始のための分析データが見つかりません。', 'error');
            return;
        }

        const { stopLoss, takeProfit } = analysisResult;

        openPositions[timeframe][pair] = { 
            signal, 
            entryPrice, 
            stopLoss, 
            takeProfit, 
            currentPrice: entryPrice, 
            amount: amount, 
            pnl: 0, 
            pnlPercent: 0, 
            timestamp: Date.now() 
        };
        savePositions();
        updatePositionsUI();
        createToast(`${pair} ${signal.toUpperCase()} (${timeframe}) ポジション保有`, 'success');
    }

    function savePositions() { localStorage.setItem('openPositions', JSON.stringify(openPositions)); }

    async function closePositionManually(pair, timeframe) {
        const assetConfig = ASSET_CONFIGS.find(c => c.pair === pair);
        if (!assetConfig) return;

        const priceData = await fetchCurrentPrice([assetConfig]);
        if (priceData && priceData[assetConfig.fsym] && priceData[assetConfig.fsym][assetConfig.tsym]) {
            closePosition(pair, priceData[assetConfig.fsym][assetConfig.tsym].PRICE, '手動決済', timeframe);
        } else {
            createToast(`${pair}の価格取得に失敗`, 'error');
        }
    }

    function closePosition(pair, exitPrice, reason, timeframe) {
        const position = openPositions[timeframe]?.[pair];
        if (!position) return;

        const pnl = (exitPrice - position.entryPrice) * (position.signal === 'buy' ? 1 : -1) * position.amount;
        const pnlPercent = ((exitPrice - position.entryPrice) / position.entryPrice) * 100 * (position.signal === 'buy' ? 1 : -1);
        
        tradeHistory.unshift({ 
            pair, 
            signal: position.signal, 
            entryPrice: position.entryPrice, 
            exitPrice, 
            pnl: pnl, 
            pnlPercent: pnlPercent.toFixed(2), 
            entryTime: position.timestamp, 
            exitTime: Date.now(), 
            reason, 
            amount: position.amount,
            timeframe
        });
        if(tradeHistory.length > 50) tradeHistory.pop();
        localStorage.setItem('tradeHistory', JSON.stringify(tradeHistory));
        
        delete openPositions[timeframe][pair];
        if (Object.keys(openPositions[timeframe]).length === 0) {
            delete openPositions[timeframe];
        }
        savePositions();
        updatePositionsUI();
        populateTradeHistoryPanel();
        createToast(`${pair} (${timeframe}) を${reason}で決済`, 'info');
    }
    
    async function updateOpenPositions() {
        const configsToUpdate = [];
        for (const timeframe in openPositions) {
            for (const pair in openPositions[timeframe]) {
                const found = ASSET_CONFIGS.find(c => c.pair === pair);
                if (found && !configsToUpdate.some(c => c.pair === pair)) {
                    configsToUpdate.push(found);
                }
            }
        }
        if (configsToUpdate.length === 0) return;

        const priceData = await fetchCurrentPrice(configsToUpdate);
        if (!priceData) return;

        let positionChanged = false;
        for (const timeframe in openPositions) {
            for (const pair in openPositions[timeframe]) {
                const pos = openPositions[timeframe][pair];
                const assetConfig = ASSET_CONFIGS.find(c => c.pair === pair);
                if (!assetConfig) continue;
                
                if (priceData[assetConfig.fsym] && priceData[assetConfig.fsym][assetConfig.tsym]) {
                    const currentPrice = priceData[assetConfig.fsym][assetConfig.tsym].PRICE;
                    pos.currentPrice = currentPrice;
                    pos.pnl = (currentPrice - pos.entryPrice) * (pos.signal === 'buy' ? 1 : -1) * pos.amount;
                    pos.pnlPercent = ((currentPrice - pos.entryPrice) / pos.entryPrice) * 100 * (pos.signal === 'buy' ? 1 : -1);
                    positionChanged = true;

                    // Auto close on SL/TP hit
                    if (pos.signal === 'buy' && (currentPrice >= pos.takeProfit || currentPrice <= pos.stopLoss)) {
                        const reason = currentPrice >= pos.takeProfit ? '利確' : '損切り';
                        closePosition(pair, currentPrice, reason, timeframe);
                    } else if (pos.signal === 'sell' && (currentPrice <= pos.takeProfit || currentPrice >= pos.stopLoss)) {
                        const reason = currentPrice <= pos.takeProfit ? '利確' : '損切り';
                        closePosition(pair, currentPrice, reason, timeframe);
                    }
                }
            }
        }
        if (positionChanged) {
            savePositions();
            updatePositionsUI();
        }
    }
    
    function updatePositionsUI() {
        positionsContainer.innerHTML = '';
        const hasOpenPositions = Object.keys(openPositions).some(timeframe => Object.keys(openPositions[timeframe]).length > 0);

        if (hasOpenPositions) {
            positionsSection.classList.remove('hidden');
        } else {
            positionsSection.classList.add('hidden');
            return;
        }

        for (const timeframe in openPositions) {
            for (const pair in openPositions[timeframe]) {
                const pos = openPositions[timeframe][pair];
                const assetConfig = ASSET_CONFIGS.find(c => c.pair === pair);
                if (!assetConfig) continue;

                const isJpyQuote = assetConfig.tsym === 'JPY';
                const pnlInTargetCurrency = pos.pnl; // PnL is already in the quote currency
                const pnlInJPY = isJpyQuote ? pnlInTargetCurrency : pnlInTargetCurrency * jpyRate;
                const evalAmountInTarget = pos.currentPrice * pos.amount;
                const evalAmountJPY = isJpyQuote ? evalAmountInTarget : evalAmountInTarget * jpyRate;
                
                const currencySymbol = isJpyQuote ? '¥' : '$';
                const locale = isJpyQuote ? 'ja-JP' : 'en-US';

                const pnlColor = pnlInJPY >= 0 ? 'text-green-400' : 'text-red-400';
                const card = document.createElement('div');
                card.className = 'bg-gray-800/50 p-4 rounded-lg border border-gray-700';
                card.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            <div class="flex items-center gap-2">
                                <span class="font-bold text-lg text-white">${pair}</span>
                                <span class="px-2 py-1 text-xs rounded-full ${pos.signal === 'buy' ? 'bg-green-500' : 'bg-red-500'}">${pos.signal.toUpperCase()}</span>
                                <span class="px-2 py-1 text-xs rounded-full bg-gray-600">${timeframe}</span>
                            </div>
                            <p class="text-xs text-gray-400">保有数量: ${pos.amount.toFixed(6)}</p>
                        </div>
                        <div class="text-right">
                            <p class="font-bold text-lg ${pnlColor}">¥${pnlInJPY.toLocaleString('ja-JP', { maximumFractionDigits: 0 })} (${pos.pnlPercent.toFixed(2)}%)</p>
                            <p class="text-xs text-gray-400">評価額: ¥${evalAmountJPY.toLocaleString('ja-JP', { maximumFractionDigits: 0 })}</p>
                        </div>
                    </div>
                    <div class="text-xs mt-2 text-gray-500 flex justify-between items-center">
                        <span>参入: ${currencySymbol}${pos.entryPrice.toLocaleString(locale)} | 利確: ${currencySymbol}${pos.takeProfit.toLocaleString(locale)} | 損切: ${currencySymbol}${pos.stopLoss.toLocaleString(locale)}</span>
                        <button data-pair="${pair}" data-timeframe="${timeframe}" class="close-position-btn text-xs bg-red-600 hover:bg-red-500 text-white py-1 px-2 rounded">ポジション決済</button>
                    </div>`;
                positionsContainer.appendChild(card);
            }
        }
    }

    function getModelAccuracy(pair, timeframe) {
        const relevantSignals = signalHistory.filter(s => s.pair === pair && s.timeframe === timeframe && s.status !== 'pending');
        if (relevantSignals.length === 0) return { rate: null, count: 0 };
        const successful = relevantSignals.filter(s => s.status === 'success').length;
        return { rate: (successful / relevantSignals.length) * 100, count: relevantSignals.length };
    }

    function createReportCard(result, rank, timeframe) {
        // ★★★ START: エラーハンドリングを追加 ★★★
        if (!result || !result.assetConfig) {
            console.error('createReportCardに無効なresultオブジェクトが渡されました:', result);
            return document.createElement('div'); // 空のdivを返して処理を中断
        }
        // ★★★ END: エラーハンドリングを追加 ★★★
        const confidence = getConfidenceLevel(result.score);
        const confidenceRank = confidence.rank;
        const confidenceClass = confidence.class;
        const card = document.createElement('div');
        card.className = 'bg-gray-800/50 backdrop-blur-sm p-6 rounded-xl shadow-lg border border-gray-700';
        
        const { pair, fsym, tsym, type } = result.assetConfig;
        card.dataset.cardPair = pair;
        
        const currencySymbol = tsym === 'JPY' ? '¥' : '$';
        const locale = tsym === 'JPY' ? 'ja-JP' : 'en-US';

        const signalColorClass = result.signal === 'buy' ? 'text-green-400' : (result.signal === 'sell' ? 'text-red-400' : 'text-yellow-400');
        const signalText = result.signal.toUpperCase();
        const rankBadgeHTML = rank ? `<span class="rank-badge rank-${rank}">${rank}</span>` : '';
        const tradeButtonHTML = result.signal !== 'hold' ? `<button data-pair="${pair}" data-signal="${result.signal}" data-timeframe="${timeframe}" class="start-trade-btn text-sm bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">このシグナルで取引</button>` : '';
        const winRateColor = result.winRate > 65 ? 'bg-green-500' : result.winRate > 50 ? 'bg-yellow-500' : 'bg-red-500';

        const impulseStatus = result.elderImpulse[result.elderImpulse.length-1];
        const impulseDotHTML = `<span class="impulse-dot impulse-${impulseStatus}" title="エルダー・インパルス・システム: ${impulseStatus}"></span>`;

        const { rate: modelRate, count: modelCount } = result.modelAccuracy;
        let modelAccuracyHTML = '';
        if (modelRate !== null) {
            const modelRateColor = modelRate > 65 ? 'text-green-400' : modelRate > 50 ? 'text-yellow-400' : 'text-red-400';
            modelAccuracyHTML = `
                <div class="flex justify-between items-center mt-3 pt-3 border-t border-gray-700/50">
                    <span class="text-sm font-semibold text-gray-300">
                        分析モデル正答率
                        <span class="text-xs text-gray-500"> (過去${modelCount}回)</span>
                    </span>
                    <span class="text-xl font-bold ${modelRateColor}">${modelRate.toFixed(1)}%</span>
                </div>`;
        } else {
             modelAccuracyHTML = `
                <div class="flex justify-between items-center mt-3 pt-3 border-t border-gray-700/50">
                    <span class="text-sm font-semibold text-gray-300">分析モデル正答率</span>
                    <span class="text-sm font-bold text-gray-500">データ収集中</span>
                </div>`;
        }

        // ★★★ START: 総合スコア表示を追加し、レイアウトを3カラムに変更 ★★★
        const topGridHTML = `
            <div class="grid grid-cols-3 gap-4 text-center items-center">
                <div>
                    <h3 class="text-sm font-semibold text-gray-400 mb-1">総合シグナル</h3>
                    <div class="text-4xl font-extrabold ${signalColorClass}">${signalText}</div>
                </div>
                <div>
                    <h3 class="text-sm font-semibold text-gray-400 mb-1">総合スコア</h3>
                    <div class="text-4xl font-extrabold ${signalColorClass} flex items-center justify-center">
                        ${result.score.toFixed(2)}
                        <span class="confidence-badge ${confidenceClass}">${confidenceRank}</span>
                    </div>
                </div>
                <div>
                     <h3 class="text-sm font-semibold text-gray-400 mb-1">
                        <span class="inline-flex items-center justify-center gap-1">
                            推奨レバレッジ
                            <div class="tooltip">
                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>
                                 <span class="tooltiptext">分析スコアの強さに応じて推奨レバレッジを計算します。スコアが高いほど高いレバレッジが推奨されます。</span>
                            </div>
                        </span>
                    </h3>
                    <div class="text-3xl font-bold ${signalColorClass}">${result.leverage > 1 ? `${result.leverage}倍` : '---'}</div>
                </div>
            </div>
        `;
        // ★★★ END: 総合スコア表示を追加し、レイアウトを3カラムに変更 ★★★
        
        card.innerHTML = `
            <div class="flex flex-wrap items-center justify-between border-b-2 border-gray-700 pb-4 mb-4 gap-4">
                <div class="flex items-center gap-4">
                    ${rankBadgeHTML}
                    <div>
                        <h2 class="text-2xl font-bold text-white flex items-center">${pair} ${impulseDotHTML}</h2>
                        <p class="text-sm text-gray-400">分析時価格: ${currencySymbol}${result.currentPrice.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 5 })}</p>
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <button data-pair="${pair}" data-takeprofit="${result.takeProfit}" data-stoploss="${result.stopLoss}" data-fiblevels='${JSON.stringify(result.fibLevels)}' data-pivotlevels='${JSON.stringify(result.pivotLevels)}' data-impulse='${JSON.stringify(result.elderImpulse)}' class="view-chart-btn text-sm bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-md transition duration-300">チャート表示</button>
                    ${tradeButtonHTML}
                </div>
            </div>
            <div class="grid md:grid-cols-2 gap-8">
                <div class="flex flex-col gap-6">
                    ${topGridHTML}
                        <div>
                            <h3 class="text-sm font-semibold text-gray-400 mb-2 flex items-center gap-1">
                                <span>短期価格予測レンジ</span>
                                <div class="tooltip">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>
                                    <span class="tooltiptext">現在のボラティリティ(ATR)に基づき、次の足で到達する可能性が高い価格帯を統計的に予測します。</span>
                                </div>
                            </h3>
                            <div class="bg-gray-900/50 p-3 rounded-lg text-center">
                                <p class="text-xl font-bold text-white">
                                    ${currencySymbol}${result.priceRangeLower.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 5 })}
                                    <span class="text-gray-500 mx-1">~</span>
                                    ${currencySymbol}${result.priceRangeUpper.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 5 })}
                                </p>
                            </div>
                        </div>
                    <div>
                        <h3 class="text-sm font-semibold text-gray-400 mb-2">最適利確・損切り分析</h3>
                        <div class="space-y-3 bg-gray-900/50 p-4 rounded-lg">
                             <div class="flex justify-between items-center">
                                 <span class="text-sm font-semibold text-gray-300">確証率 (相場の勝ちやすさ)</span>
                                 <span class="text-xl font-bold ${result.winRate > 65 ? 'text-green-400' : 'text-yellow-400'}">${result.winRate.toFixed(1)}%</span>
                             </div>
                            <div class="w-full bg-gray-700 rounded-full h-2.5"><div class="${winRateColor} h-2.5 rounded-full" style="width: ${result.winRate}%"></div></div>
                            <div class="flex justify-between">
                                <div><p class="text-xs text-green-400 font-semibold">最適利確</p><p class="text-lg font-bold text-white">${currencySymbol}${result.takeProfit.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 5 })}</p></div>
                                <div class="text-right"><p class="text-xs text-red-400 font-semibold">最適損切り</p><p class="text-lg font-bold text-white">${currencySymbol}${result.stopLoss.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 5 })}</p></div>
                            </div>
                            ${modelAccuracyHTML}
                        </div>
                    </div>
                </div>
                <div>
                    <h3 class="text-lg font-bold mb-3 text-white">分析根拠</h3>
                    <ul class="space-y-2 text-gray-300 text-sm">${result.keyReasons && result.keyReasons.length > 0 ? result.keyReasons.map(r => `<li>${r}</li>`).join('') : '<li>分析根拠データなし</li>'}</ul>
                    <div class="mt-4 grid grid-cols-2 gap-4">
                        <div>
                             <h4 class="text-sm font-semibold text-gray-400 mb-1">フィボナッチ</h4>
                             <ul class="text-xs text-gray-500">
                                 ${Object.entries(result.fibLevels).map(([level, value]) => `<li>${level.replace('level', '')}%: ${currencySymbol}${value.toLocaleString(locale, { maximumFractionDigits: 2 })}</li>`).join('')}
                             </ul>
                        </div>
                        <div>
                             <h4 class="text-sm font-semibold text-gray-400 mb-1">ピボットポイント</h4>
                             <ul class="text-xs text-gray-500">
                                 ${result.pivotLevels ? Object.entries(result.pivotLevels).map(([level, value]) => `<li>${level.toUpperCase()}: ${currencySymbol}${value.toLocaleString(locale, { maximumFractionDigits: 2 })}</li>`).join('') : '<li>データなし</li>'}
                             </ul>
                        </div>
                    </div>
                </div>
            </div>`;
        return card;
    }

    // --- History Panels ---
    function populateHistoryPanel() {
        panels.history.innerHTML = '';
        if (analysisHistory.length === 0) {
            panels.history.innerHTML = `<div class="text-center text-gray-500 py-10"><p>分析履歴はありません。</p></div>`;
            return;
        }

        analysisHistory.forEach(report => {
            const reportEl = document.createElement('div');
            const date = new Date(report.timestamp);
            reportEl.innerHTML = `<h3 class="text-xl font-bold text-white mb-4 border-b border-gray-700 pb-2">${date.toLocaleString()} の分析結果 (${timeframeConfigs[report.timeframe]?.label || report.timeframe})</h3>`;
            const resultsGrid = document.createElement('div');
            resultsGrid.className = 'space-y-4';
            if (report.results && report.results.length > 0) {
                report.results.sort((a,b) => Math.abs(b.score) - Math.abs(a.score)).slice(0,3).forEach((result, index) => {
                    // ★★★ START: 古いデータ形式でもエラーが出ないように修正 ★★★
                    // resultオブジェクトと、その中のassetConfigが存在することを確認してからカードを作成する
                    if (result && result.assetConfig) {
                        resultsGrid.appendChild(createReportCard(result, index + 1, report.timeframe));
                    }
                    // ★★★ END: 修正 ★★★
                });
            }
            reportEl.appendChild(resultsGrid);
            panels.history.appendChild(reportEl);
        });
    }

    function populateTradeHistoryPanel() {
        panels.tradeHistory.innerHTML = '';
        if (tradeHistory.length === 0) {
            panels.tradeHistory.innerHTML = `<div class="text-center text-gray-500 py-10"><p>取引履歴はありません。</p></div>`;
            return;
        }

        tradeHistory.forEach(trade => {
            const assetConfig = ASSET_CONFIGS.find(c => c.pair === trade.pair);
            if (!assetConfig) return;

            const card = document.createElement('div');
            card.className = 'bg-gray-900/50 p-4 rounded-lg flex justify-between items-center';
            
            const isJpyQuote = assetConfig.tsym === 'JPY';
            const currencySymbol = isJpyQuote ? '¥' : '$';
            const locale = isJpyQuote ? 'ja-JP' : 'en-US';
            const pnlInJpy = isJpyQuote ? trade.pnl : (trade.pnl * jpyRate);
            const pnlColor = pnlInJpy >= 0 ? 'text-green-400' : 'text-red-400';
            const entryTime = new Date(trade.entryTime).toLocaleString();
            const exitTime = new Date(trade.exitTime).toLocaleString();

            card.innerHTML = `
                <div>
                    <div class="flex items-center gap-2">
                         <span class="font-bold text-lg text-white">${trade.pair}</span>
                         <span class="px-2 py-1 text-xs rounded-full ${trade.signal === 'buy' ? 'bg-green-500' : 'bg-red-500'}">${trade.signal.toUpperCase()}</span>
                         <span class="px-2 py-1 text-xs rounded-full bg-gray-600">${timeframeConfigs[trade.timeframe]?.label || trade.timeframe}</span>
                    </div>
                    <p class="text-xs text-gray-400 mt-1">期間: ${entryTime} ~ ${exitTime}</p>
                    <p class="text-xs text-gray-400">理由: ${trade.reason}</p>
                </div>
                <div class="text-right">
                    <p class="font-bold text-lg ${pnlColor}">¥${pnlInJpy.toLocaleString('ja-JP', { maximumFractionDigits: 0 })} (${trade.pnlPercent}%)</p>
                    <p class="text-xs text-gray-500">参入: ${currencySymbol}${trade.entryPrice.toLocaleString(locale)} → 決済: ${currencySymbol}${trade.exitPrice.toLocaleString(locale)}</p>
                </div>
            `;
            panels.tradeHistory.appendChild(card);
        });
    }

    // --- Indicator Calculation Functions ---
    function safeCalculateIndicator(calculateFunc, ...args) {
      try {
        const result = calculateFunc(...args);
        // Ensure result is not undefined/null and is an array or object
        if (result !== null && result !== undefined) {
          return result;
        }
        throw new Error("Calculation returned null or undefined.");
      } catch (error) {
        console.warn(`Indicator calculation failed for ${calculateFunc.name}: ${error.message}, returning default.`);
        const data = args[0];
        if (Array.isArray(data)) {
            // Heuristic to guess if the output should be an array or a single value
            if (calculateFunc.name === 'calculateVWAP' || calculateFunc.name === 'calculateSlope') return 0;
            // Heuristic for object outputs
            if (calculateFunc.name.includes('Stochastic') || calculateFunc.name.includes('MACD') || calculateFunc.name.includes('Bollinger') || calculateFunc.name.includes('Ichimoku')) return {};
            return Array(data.length).fill(0);
        }
        return 0;
      }
    }

    const calculateSMA = (data, period) => {
        let sma = [];
        for (let i = period - 1; i < data.length; i++) {
            const slice = data.slice(i - period + 1, i + 1);
            const sum = slice.reduce((a, b) => a + b, 0);
            sma.push(sum / period);
        }
        return sma;
    };
    const calculateEMA = (data, period) => {
        if (data.length < period) return [];
        let ema = [];
        const multiplier = 2 / (period + 1);
        let firstSma = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
        ema.push(firstSma);
        for (let i = period; i < data.length; i++) {
            const currentEma = (data[i] - ema[ema.length - 1]) * multiplier + ema[ema.length - 1];
            ema.push(currentEma);
        }
        return ema;
    };
    // ★★★ START: CCI計算関数を追加 ★★★
    const calculateCCI = (highs, lows, closes, period) => {
        if (closes.length < period) return [];
        let tp = [];
        for (let i = 0; i < closes.length; i++) {
            tp.push((highs[i] + lows[i] + closes[i]) / 3);
        }
        const smaTp = calculateSMA(tp, period);
        let meanDeviation = [];
        const tpSliceForMd = tp.slice(tp.length - smaTp.length);

        for(let i = 0; i < smaTp.length; i++) {
            const start = Math.max(0, i - period + 1);
            const slice = tpSliceForMd.slice(start, i + 1);
            const devSum = slice.reduce((acc, val) => acc + Math.abs(val - smaTp[i]), 0);
            meanDeviation.push(devSum / slice.length);
        }

        let cci = [];
        const dataOffset = smaTp.length - meanDeviation.length;
        
        for(let i = 0; i < meanDeviation.length; i++) {
             const currentTp = tpSliceForMd[i + dataOffset];
             const currentSma = smaTp[i + dataOffset];
             const currentMd = meanDeviation[i];

            if (currentMd === 0) {
                cci.push(0);
            } else {
                cci.push((currentTp - currentSma) / (0.015 * currentMd));
            }
        }
        return cci;
    };
    // ★★★ END: CCI計算関数を追加 ★★★
    const calculateMACD = (ema12, ema26, signalPeriod) => {
        let macdLine = [];
        const start = ema26.length - ema12.length;
        for (let i = 0; i < ema12.length; i++) {
            if(i + start >= 0) macdLine.push(ema12[i] - ema26[i + start]);
        }
        const signalLine = calculateEMA(macdLine, signalPeriod);
        const histogram = [];
        const sigStart = macdLine.length - signalLine.length;
        for (let i = 0; i < signalLine.length; i++) {
            histogram.push(macdLine[i + sigStart] - signalLine[i]);
        }
        return { macdLine, signalLine, histogram };
    };
    const calculateRSI = (data, period) => {
        let rsi = []; let gains = 0; let losses = 0;
        for (let i = 1; i < data.length; i++) {
            const diff = data[i] - data[i - 1];
            if (i <= period) {
                if (diff >= 0) gains += diff; else losses -= diff;
            } else {
                if (diff >= 0) gains = (gains * (period - 1) + diff) / period; else losses = (losses * (period - 1) - diff) / period;
            }
            if (i >= period) {
                const rs = losses === 0 ? 100 : gains / losses;
                rsi.push(100 - (100 / (1 + rs)));
            }
        }
        return rsi;
    };
    const calculateStochastic = (closes, highs, lows, period, kSlowing) => {
        let k = [];
        for (let i = period - 1; i < closes.length; i++) {
            const sliceCloses = closes.slice(i - period + 1, i + 1);
            const sliceHighs = highs.slice(i - period + 1, i + 1);
            const sliceLows = lows.slice(i - period + 1, i + 1);
            const high = Math.max(...sliceHighs);
            const low = Math.min(...sliceLows);
            k.push(((sliceCloses[sliceCloses.length-1] - low) / (high - low)) * 100);
        }
        const d = calculateSMA(k, kSlowing);
        return { k, d };
    };
    const calculateBollingerBands = (data, period, stdDev) => {
        const sma = calculateSMA(data, period);
        let upper = [], lower = [], middle = [];
        const dataSlice = data.slice(period - 1);
        for(let i = 0; i < sma.length; i++) {
            const slice = dataSlice.slice(i - period + 1 > 0 ? i - period + 1 : 0, i + 1);
            const std = Math.sqrt(slice.reduce((acc, val) => acc + Math.pow(val - sma[i], 2), 0) / period);
            middle.push(sma[i]);
            upper.push(sma[i] + (std * stdDev));
            lower.push(sma[i] - (std * stdDev));
        }
        return { upper, lower, middle };
    };
    const calculateIchimoku = (highs, lows, closes, params) => {
        const calculateLine = (data, period) => {
            let line = [];
            for (let i = period - 1; i < data.length; i++) {
                const slice = data.slice(i - period + 1, i + 1);
                line.push((Math.max(...slice) + Math.min(...slice)) / 2);
            }
            return line;
        };
        const tenkan = calculateLine(highs, params.tenkan);
        const kijun = calculateLine(highs, params.kijun);
        let senkouA = [], senkouB = [];
        for(let i = params.kijun - 1; i < tenkan.length; i++) senkouA.push((tenkan[i] + kijun[i]) / 2);
        const senkouBData = calculateLine(highs, params.senkouB);
        senkouB = senkouBData.slice(senkouBData.length - senkouA.length);
        return { tenkan, kijun, senkouA, senkouB };
    };
     const calculateVWAP = (closes, highs, lows, volumes) => {
         if(closes.length === 0) return 0;
        let cumulativeTPV = 0; let cumulativeVolume = 0;
        for (let i = 0; i < closes.length; i++) {
            const tp = (highs[i] + lows[i] + closes[i]) / 3;
            cumulativeTPV += tp * volumes[i];
            cumulativeVolume += volumes[i];
        }
        return cumulativeVolume > 0 ? cumulativeTPV / cumulativeVolume : 0;
    };
    const calculateParabolicSAR = (highs, lows, params) => {
        let psar = []; let ep = lows[0]; let af = params.psarStart; let isRising = true;
        psar.push(highs[0]);
        for (let i = 1; i < highs.length; i++) {
            let currentPsar;
            if (isRising) {
                currentPsar = psar[i - 1] + af * (ep - psar[i - 1]);
                if (lows[i] < currentPsar) {
                    isRising = false; currentPsar = ep; af = params.psarStart; ep = lows[i];
                } else {
                    if (highs[i] > ep) { ep = highs[i]; af = Math.min(params.psarMax, af + params.psarIncrement); }
                }
            } else {
                currentPsar = psar[i - 1] - af * (psar[i - 1] - ep);
                if (highs[i] > currentPsar) {
                    isRising = true; currentPsar = ep; af = params.psarStart; ep = highs[i];
                } else {
                    if (lows[i] < ep) { ep = lows[i]; af = Math.min(params.psarMax, af + params.psarIncrement); }
                }
            }
            psar.push(currentPsar);
        }
        return psar;
    };
    const calculateATR = (highs, lows, closes, period) => {
        let tr = [highs[0] - lows[0]];
        for (let i = 1; i < highs.length; i++) {
            tr.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i-1]), Math.abs(lows[i] - closes[i-1])));
        }
        return calculateEMA(tr, period);
    };
    const calculateADX = (highs, lows, closes, period) => {
        let plusDM = [], minusDM = [];
        for (let i = 1; i < highs.length; i++) {
            const upMove = highs[i] - highs[i-1];
            const downMove = lows[i-1] - lows[i];
            plusDM.push(upMove > downMove && upMove > 0 ? upMove : 0);
            minusDM.push(downMove > upMove && downMove > 0 ? downMove : 0);
        }
        const atr = calculateATR(highs, lows, closes, period);
        const emaPlusDM = calculateEMA(plusDM, period);
        const emaMinusDM = calculateEMA(minusDM, period);
        let plusDI = [], minusDI = [], dx = [], adx = [];
        const start = atr.length - emaPlusDM.length;
        for (let i = 0; i < emaPlusDM.length; i++) {
            if (atr[i + start] > 0) {
                plusDI.push(100 * (emaPlusDM[i] / atr[i + start]));
                minusDI.push(100 * (emaMinusDM[i] / atr[i + start]));
                const diDiff = Math.abs(plusDI[i] - minusDI[i]);
                const diSum = plusDI[i] + minusDI[i];
                dx.push(diSum === 0 ? 0 : 100 * (diDiff / diSum));
            } else {
                plusDI.push(0);
                minusDI.push(0);
                dx.push(0);
            }
        }
        adx = calculateEMA(dx, period);
        return { adx, plusDI, minusDI };
    };
    const calculateSlope = (data, period) => {
        if(data.length < period) return 0;
        const recentData = data.slice(-period);
        const n = recentData.length;
        const sumX = (n * (n - 1)) / 2;
        const sumY = recentData.reduce((a, b) => a + b, 0);
        const sumXY = recentData.reduce((acc, y, i) => acc + i * y, 0);
        const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        return slope;
    };
    const calculateBollingerBandWidth = (bb) => {
        let bbw = [];
        for(let i = 0; i < bb.middle.length; i++) {
            bbw.push((bb.upper[i] - bb.lower[i]) / bb.middle[i]);
        }
        return bbw;
    };
    const calculateOBV = (closes, volumes) => {
        let obv = [0];
        for(let i=1; i < closes.length; i++) {
            if (closes[i] > closes[i-1]) obv.push(obv[i-1] + volumes[i]);
            else if (closes[i] < closes[i-1]) obv.push(obv[i-1] - volumes[i]);
            else obv.push(obv[i-1]);
        }
        return obv;
    };
    const calculateElderImpulse = (ema, macdHistogram) => {
        let impulse = [];
        const startIdx = ema.length - macdHistogram.length;
        for (let i = 1; i < macdHistogram.length; i++) {
            const emaIsUp = ema[i + startIdx] > ema[i + startIdx - 1];
            const macdIsUp = macdHistogram[i] > macdHistogram[i-1];
            if (emaIsUp && macdIsUp) impulse.push('green');
            else if (!emaIsUp && !macdIsUp) impulse.push('red');
            else impulse.push('blue');
        }
        return impulse;
    };
    function calculateFibonacciRetracement(high, low) {
      if(high === low) return {};
      return {
        level0: high,
        level236: high - (high - low) * 0.236,
        level382: high - (high - low) * 0.382,
        level500: high - (high - low) * 0.5,
        level618: high - (high - low) * 0.618,
        level786: high - (high - low) * 0.786,
        level100: low
      };
    }
    function calculatePivotPoints(high, low, close) {
        const pivot = (high + low + close) / 3;
        const r1 = (2 * pivot) - low;
        const s1 = (2 * pivot) - high;
        const r2 = pivot + (high - low);
        const s2 = pivot - (high - low);
        return { r2, r1, pivot, s1, s2 };
    }

    // ★★★ START: デイトレード向けオーダーブロック検出関数を追加 ★★★
    function detectOrderBlocks(data, lookback = 50) {
        const recentData = data.slice(-lookback);
        let bullishOB = null;
        let bearishOB = null;

        if(recentData.length < 5) return { bullish: null, bearish: null };

        // 平均的なローソク足の実体のサイズを計算
        const avgBodySize = recentData.slice(-20).reduce((sum, c) => sum + Math.abs(c.close - c.open), 0) / 20;

        for (let i = recentData.length - 3; i >= 1; i--) {
            const candle = recentData[i];
            const nextCandle = recentData[i+1];
            
            const isCandleBearish = candle.close < candle.open;
            const isCandleBullish = candle.close > candle.open;
            
            // 次の足が前の足の高値/安値を大きく更新したか（構造の変化）
            const isStrongMoveUp = nextCandle.close > candle.high && (nextCandle.close - nextCandle.open) > avgBodySize * 1.5;
            const isStrongMoveDown = nextCandle.close < candle.low && (nextCandle.open - nextCandle.close) > avgBodySize * 1.5;

            // 強力な上昇の前の最後の下降足（強気のオーダーブロック）
            if (!bullishOB && isCandleBearish && isStrongMoveUp) {
                bullishOB = { high: candle.high, low: candle.low, index: data.length - lookback + i };
            }

            // 強力な下降の前の最後の上昇足（弱気のオーダーブロック）
            if (!bearishOB && isCandleBullish && isStrongMoveDown) {
                bearishOB = { high: candle.high, low: candle.low, index: data.length - lookback + i };
            }

            if (bullishOB && bearishOB) break;
        }

        return { bullish: bullishOB, bearish: bearishOB };
    }
    // ★★★ END: デイトレード向けオーダーブロック検出関数を追加 ★★★

    // --- Price Ticker ---
    async function initializePriceTicker() {
        const initialPrices = await fetchCurrentPrice(ASSET_CONFIGS);
        if(!initialPrices) return;
        
        let itemsHTML = '';
        ASSET_CONFIGS.forEach(config => {
            const { pair, fsym, tsym } = config;
            const currencySymbol = tsym === 'JPY' ? '¥' : '$';
            const locale = tsym === 'JPY' ? 'ja-JP' : 'en-US';
            const data = initialPrices[fsym]?.[tsym];

            if(data) {
                const changePct = data.CHANGEPCT24HOUR || 0;
                const color = changePct >= 0 ? 'text-green-400' : 'text-red-400';
                itemsHTML += `<div class="ticker-item" data-ticker-pair="${pair}">
                    <span class="font-bold mr-2">${pair}</span>
                    <span class="mr-2">${currencySymbol}${data.PRICE.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 5 })}</span>
                    <span class="${color}">${changePct.toFixed(2)}%</span>
                </div>`;
            }
        });
        
        priceTickerContainer.innerHTML = itemsHTML;
        priceTickerContainer.innerHTML += itemsHTML; // Duplicate for seamless scroll
        
        quickPriceView.innerHTML = '';
        ASSET_CONFIGS.slice(0, 6).forEach(config => {
             const { pair, fsym, tsym } = config;
             const currencySymbol = tsym === 'JPY' ? '¥' : '$';
             const locale = tsym === 'JPY' ? 'ja-JP' : 'en-US';
             const data = initialPrices[fsym]?.[tsym];

             if(data) {
                 const changePct = data.CHANGEPCT24HOUR || 0;
                 const color = changePct >= 0 ? 'text-green-400' : 'text-red-400';
                 const div = document.createElement('div');
                 div.className = 'bg-gray-800/50 p-3 rounded-lg text-center';
                 div.dataset.quickPair = pair;
                 div.innerHTML = `
                     <p class="font-bold text-white">${pair}</p>
                     <p class="text-lg font-semibold">${currencySymbol}${data.PRICE.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 5 })}</p>
                     <p class="text-sm ${color}">${changePct.toFixed(2)}%</p>
                 `;
                 quickPriceView.appendChild(div);
             }
        });
    }

    async function updateTickerPrices() {
        const prices = await fetchCurrentPrice(ASSET_CONFIGS);
        if(!prices) return;

        ASSET_CONFIGS.forEach(config => {
            const { pair, fsym, tsym } = config;
            const currencySymbol = tsym === 'JPY' ? '¥' : '$';
            const locale = tsym === 'JPY' ? 'ja-JP' : 'en-US';
            const data = prices[fsym]?.[tsym];

            if(data) {
                const changePct = data.CHANGEPCT24HOUR || 0;
                const color = changePct >= 0 ? 'text-green-400' : 'text-red-400';
                
                document.querySelectorAll(`[data-ticker-pair="${pair}"]`).forEach(el => {
                    el.children[1].textContent = `${currencySymbol}${data.PRICE.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 5 })}`;
                    el.children[2].className = color;
                    el.children[2].textContent = `${changePct.toFixed(2)}%`;
                });

                const quickEl = document.querySelector(`[data-quick-pair="${pair}"]`);
                if(quickEl) {
                     quickEl.children[1].textContent = `${currencySymbol}${data.PRICE.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 5 })}`;
                     quickEl.children[2].className = `text-sm ${color}`;
                     quickEl.children[2].textContent = `${changePct.toFixed(2)}%`;
                }
            }
        });
    }
    
    // --- Modals and Menu Logic ---
    function setupModals() {
        menuButton.addEventListener('click', () => menuDropdown.classList.toggle('hidden'));
        document.addEventListener('click', (e) => {
            if (!headerMenu.contains(e.target)) menuDropdown.classList.add('hidden');
        });

        const openModal = (modalEl, openerEl) => {
            openerEl.addEventListener('click', (e) => { e.preventDefault(); modalEl.classList.remove('hidden'); });
        };
        const closeModal = (modalEl, closerEl) => {
            closerEl.addEventListener('click', () => modalEl.classList.add('hidden'));
        };

        openModal(settingsModal, menuSettings);
        closeModal(settingsModal, closeSettingsModal);
        openModal(aiModal, menuAiAnalysis);
        closeModal(aiModal, closeAiModal);
        openModal(qaModal, menuQa);
        closeModal(qaModal, closeQaModal);
        openModal(notificationsModal, menuNotifications);
        closeModal(notificationsModal, closeNotificationsModal);
        closeModal(chartModal, closeChartModal);
    }
    
    function populateSettingsForm() {
        customizationForm.innerHTML = '';
        Object.entries(baseAnalysisSettings.weights).forEach(([key, value]) => {
            const div = document.createElement('div');
            div.className = 'grid grid-cols-2 items-center';
            div.innerHTML = `<label for="weight-${key}" class="text-sm">${key}</label><input type="number" id="weight-${key}" data-type="weights" data-key="${key}" value="${value}" step="0.1" class="w-full bg-gray-700 p-1 rounded-md text-white text-center">`;
            customizationForm.appendChild(div);
        });
        Object.entries(baseAnalysisSettings.params).forEach(([key, value]) => {
            if (typeof value === 'number') {
                const div = document.createElement('div');
                div.className = 'grid grid-cols-2 items-center';
                div.innerHTML = `<label for="param-${key}" class="text-sm">${key}</label><input type="number" id="param-${key}" data-type="params" data-key="${key}" value="${value}" step="1" class="w-full bg-gray-700 p-1 rounded-md text-white text-center">`;
                customizationForm.appendChild(div);
            }
        });
    }

    saveSettingsBtn.addEventListener('click', () => {
        const newSettings = { weights: {}, params: {} };
        customizationForm.querySelectorAll('input').forEach(input => {
            const { type, key } = input.dataset;
            newSettings[type][key] = parseFloat(input.value);
        });
        baseAnalysisSettings = newSettings;
        localStorage.setItem('analysisSettings', JSON.stringify(baseAnalysisSettings));
        createToast('設定を保存しました。', 'success');
        settingsModal.classList.add('hidden');
    });

    runBacktestBtn.addEventListener('click', async () => {
        backtestSpinner.classList.remove('hidden');
        runBacktestBtn.disabled = true;
        backtestResultsEl.classList.add('hidden');

        const timeframeKey = timeframeSelect.value;
        const config = timeframeConfigs[timeframeKey];
        const btcConfig = ASSET_CONFIGS.find(c => c.pair === 'BTC/USD');
        const data = await fetchData(btcConfig.fsym, btcConfig.tsym, config.endpoint, 500, config.aggregate);
        
        if (!data || data.length < config.limit) {
            createToast('バックテスト用のデータが不足しています。', 'error');
            backtestSpinner.classList.add('hidden');
            runBacktestBtn.disabled = false;
            return;
        }

        let tempSettings = { weights: {}, params: {} };
        customizationForm.querySelectorAll('input').forEach(input => {
            const { type, key } = input.dataset;
            tempSettings[type][key] = parseFloat(input.value);
        });

        let wins = 0, losses = 0, trades = 0;
        for (let i = config.limit; i < data.length; i++) {
            const currentData = data.slice(0, i);
            const result = await performFullTechnicalAnalysis(btcConfig, timeframeKey, currentData, true, tempSettings, null, null);
            if (result && result.signal !== 'hold') {
                trades++;
                const exitPrice = data[i].close;
                const win = (result.signal === 'buy' && exitPrice > result.currentPrice) || (result.signal === 'sell' && exitPrice < result.currentPrice);
                if (win) wins++; else losses++;
            }
        }

        backtestResultsEl.innerHTML = `
            <p><strong>バックテスト結果 (BTC/USD, ${config.label})</strong></p>
            <p>総トレード数: ${trades}</p>
            <p>勝率: ${trades > 0 ? ((wins / trades) * 100).toFixed(1) : 0}%</p>
            <p>利益: ${wins} / 損失: ${losses}</p>
        `;

        backtestResultsEl.classList.remove('hidden');
        backtestSpinner.classList.add('hidden');
        runBacktestBtn.disabled = false;
    });

    function loadNotificationSettings() {
        desktopNotifyToggle.checked = notificationSettings.desktop;
        soundNotifyToggle.checked = notificationSettings.sound;
        notifyThresholdInput.value = notificationSettings.threshold;
        notifyThresholdValue.textContent = notificationSettings.threshold.toFixed(1);
    }
    
    notifyThresholdInput.addEventListener('input', (e) => {
        notifyThresholdValue.textContent = parseFloat(e.target.value).toFixed(1);
    });
    
    saveNotifySettingsBtn.addEventListener('click', () => {
        notificationSettings.desktop = desktopNotifyToggle.checked;
        notificationSettings.sound = soundNotifyToggle.checked;
        notificationSettings.threshold = parseFloat(notifyThresholdInput.value);
        localStorage.setItem('notificationSettings', JSON.stringify(notificationSettings));
        createToast('通知設定を保存しました。', 'success');
        if (notificationSettings.desktop && Notification.permission !== 'granted') {
            Notification.requestPermission();
        }
        notificationsModal.classList.add('hidden');
    });

    function showDesktopNotification(pair, signal, score) {
        if (!("Notification" in window) || Notification.permission !== "granted") return;
        const signalText = signal === 'buy' ? '買い' : '売り';
        const notification = new Notification(`高確度シグナル: ${pair}`, {
            body: `シグナル: ${signalText}, スコア: ${score.toFixed(2)}`,
            icon: 'https://cdn-icons-png.flaticon.com/512/3688/3688225.png'
        });
    }

    function playNotificationSound() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.2);
    }

    async function showChartModal(assetConfig, takeProfit, stopLoss, fibLevels, pivotLevels, elderImpulse) {
        chartModal.classList.remove('hidden');
        chartLoadingOverlay.classList.remove('hidden');
        if(chartInstance) chartInstance.destroy();

        const timeframeKey = timeframeSelect.value;
        document.getElementById('chart-modal-title').textContent = `${assetConfig.pair} チャート分析 (${timeframeConfigs[timeframeKey].label})`;
        
        populateChartTimeframeSelector(assetConfig, takeProfit, stopLoss, fibLevels, pivotLevels, elderImpulse);
        await updateChart(timeframeKey, assetConfig, takeProfit, stopLoss, fibLevels, pivotLevels, elderImpulse);
    }
    
    function populateChartTimeframeSelector(assetConfig, takeProfit, stopLoss, fibLevels, pivotLevels, elderImpulse) {
        chartTimeframeSelector.innerHTML = '';
        Object.keys(timeframeConfigs).forEach(key => {
            const btn = document.createElement('button');
            btn.className = 'timeframe-btn';
            btn.textContent = timeframeConfigs[key].label;
            btn.dataset.timeframe = key;
            if (key === timeframeSelect.value) btn.classList.add('active');
            btn.onclick = async () => {
                chartTimeframeSelector.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                await updateChart(key, assetConfig, takeProfit, stopLoss, fibLevels, pivotLevels, elderImpulse);
            };
            chartTimeframeSelector.appendChild(btn);
        });
    }

    async function updateChart(timeframeKey, assetConfig, takeProfit, stopLoss, fibLevels, pivotLevels, elderImpulse) {
        chartLoadingOverlay.classList.remove('hidden');
            if(chartInstance) chartInstance.destroy();
        
        const config = timeframeConfigs[timeframeKey];
        const data = await fetchData(assetConfig.fsym, assetConfig.tsym, config.endpoint, config.limit, config.aggregate);
        
        if (!data) {
            chartLoadingOverlay.innerHTML = '<p class="text-red-500">チャートデータの取得に失敗しました。</p>';
            return;
        }

        const labels = data.map(d => new Date(d.time * 1000));
        const closes = data.map(d => d.close);
        const ma1 = config.useEMA ? calculateEMA(closes, config.params.emaShort) : calculateSMA(closes, config.params.smaShort);
        const ma2 = config.useEMA ? calculateEMA(closes, config.params.emaLong) : calculateSMA(closes, config.params.smaLong);
        const bb = calculateBollingerBands(closes, config.params.bbPeriod, config.params.bbStdDev);
        const annotations = {};

        annotations.takeProfit = { type: 'line', yMin: takeProfit, yMax: takeProfit, borderColor: 'rgb(34, 197, 94)', borderWidth: 2, label: { content: 'Take Profit', enabled: true, position: 'start' } };
        annotations.stopLoss = { type: 'line', yMin: stopLoss, yMax: stopLoss, borderColor: 'rgb(239, 68, 68)', borderWidth: 2, label: { content: 'Stop Loss', enabled: true, position: 'start' } };

        if (fibLevels) Object.entries(fibLevels).forEach(([level, value]) => {
            annotations[`fib${level}`] = { type: 'line', yMin: value, yMax: value, borderColor: 'rgba(251, 191, 36, 0.5)', borderWidth: 1, borderDash: [5, 5], label: { content: `${level.replace('level','')} %`, enabled: true, position: 'end', font: {size: 10} } };
        });

        if (pivotLevels) Object.entries(pivotLevels).forEach(([level, value]) => {
            annotations[`pivot${level}`] = { type: 'line', yMin: value, yMax: value, borderColor: 'rgba(167, 139, 250, 0.6)', borderWidth: 1, borderDash: [10, 10], label: { content: level.toUpperCase(), enabled: true, position: 'start', font: {size: 10} } };
        });

        const ctx = document.getElementById('chart-canvas').getContext('2d');
        chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    { label: 'Price', data: closes, borderColor: 'rgb(99, 102, 241)', borderWidth: 2, pointRadius: 0 },
                    { label: `MA ${config.params.emaShort}`, data: ma1, borderColor: 'rgba(59, 130, 246, 0.7)', borderWidth: 1, pointRadius: 0 },
                    { label: `MA ${config.params.emaLong}`, data: ma2, borderColor: 'rgba(234, 179, 8, 0.7)', borderWidth: 1, pointRadius: 0 },
                    { label: 'BB Upper', data: bb.upper, borderColor: 'rgba(200, 200, 200, 0.2)', borderWidth: 1, pointRadius: 0, fill: false },
                    { label: 'BB Lower', data: bb.lower, borderColor: 'rgba(200, 200, 200, 0.2)', borderWidth: 1, pointRadius: 0, fill: '-1' },
                ]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                scales: { x: { type: 'time', time: { unit: 'hour' }, grid: { color: 'rgba(255,255,255,0.1)' } }, y: { grid: { color: 'rgba(255,255,255,0.1)' } } },
                plugins: { legend: { display: false }, annotation: { annotations } }
            }
        });
        chartLoadingOverlay.classList.add('hidden');
    }
    
    // AI and Q&A (placeholders for now)
    qaSubmitBtn.addEventListener('click', () => {
        qaResponseContainer.innerHTML = '<p class="text-gray-400">AIが応答を生成中...</p>';
        setTimeout(() => {
            qaResponseContainer.innerHTML = `<p>「${qaInput.value}」についての回答です。総合スコアは、複数のテクニカル指標を組み合わせ、市場の状況に応じて重み付けを動的に変更して算出される独自の指標です。スコアが高いほど買い、低いほど売りの確度が高いことを示します。</p>`;
        }, 1500);
    });

    runAiPredictionBtn.addEventListener('click', async () => {
        aiSpinner.classList.remove('hidden');
        aiPredictionResultEl.textContent = '';
        
        const btcConfig = ASSET_CONFIGS.find(c => c.pair === 'BTC/USD');
        const data = await fetchData(btcConfig.fsym, btcConfig.tsym, 'histohour', 60, 1);
        if(!data) {
            aiPredictionResultEl.innerHTML = '<p class="text-red-500">予測データの取得に失敗</p>';
            aiSpinner.classList.add('hidden');
            return;
        }

        // Simplified placeholder for TF.js logic
        setTimeout(() => {
            const prediction = Math.random() > 0.5 ? '上昇' : '下降';
            const confidence = (Math.random() * (90 - 60) + 60).toFixed(1);
            const color = prediction === '上昇' ? 'text-green-400' : 'text-red-400';
            aiPredictionResultEl.innerHTML = `
                <p>次の1時間の価格変動予測:</p>
                <p class="text-3xl font-bold ${color}">${prediction}</p>
                <p class="text-sm text-gray-400">確信度: ${confidence}%</p>
            `;
            aiSpinner.classList.add('hidden');
        }, 2000);
    });
    
    // --- Initialization ---
    async function initialize() {
        await updateJpyRate();
        setInterval(updateJpyRate, 60000 * 10);
        
        await initializePriceTicker();
        setInterval(updateTickerPrices, 15000); // Update ticker more frequently

        updatePositionsUI();
        populateHistoryPanel();
        populateTradeHistoryPanel();
        populateSettingsForm();
        updateAccuracyUI();
        setInterval(verifySignals, 120000);
        setInterval(updateOpenPositions, 15000);

        setupModals();
        loadNotificationSettings();
        
        // Initial analysis run
        performAnalysis(true);
    }

    initialize();

    // Setup event listeners for new UI elements
    document.querySelectorAll('.condition-filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.condition-filter-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            updateConditionWiseStats(btn.dataset.filter);
        });
    });
});
</script>
</body>
</html>








